package automerge

//go:generate go run generate/gen.go

/*
#cgo LDFLAGS: -lautomerge
#cgo darwin,arm64 LDFLAGS: -L${SRCDIR}/deps/darwin_arm64
#cgo darwin,arm64 CFLAGS: -I${SRCDIR}/deps/darwin_arm64 -Wall

#include "automerge.h"
#include <stdlib.h>

// The below is generated by `go run ./generate/gen.go`
// unions are not directly supported by cgo, so there are accessors for
// the various flavors of AMvalue either passing the AMresult

AMvalueVariant AMresultValueTag(AMresult *r) { return AMresultValue(r).tag; }
const struct AMactorId *AMresultValueActorId(AMresult *r) { return AMresultValue(r).actor_id; }
bool AMresultValueBoolean(AMresult *r) { return AMresultValue(r).boolean; }
struct AMbyteSpan AMresultValueBytes(AMresult *r) { return AMresultValue(r).bytes; }
struct AMchangeHashes AMresultValueChangeHashes(AMresult *r) { return AMresultValue(r).change_hashes; }
struct AMchanges AMresultValueChanges(AMresult *r) { return AMresultValue(r).changes; }
int64_t AMresultValueCounter(AMresult *r) { return AMresultValue(r).counter; }
struct AMdoc *AMresultValueDoc(AMresult *r) { return AMresultValue(r).doc; }
double AMresultValueF64(AMresult *r) { return AMresultValue(r).f64; }
int64_t AMresultValueInt(AMresult *r) { return AMresultValue(r).int_; }
struct AMlistItems AMresultValueListItems(AMresult *r) { return AMresultValue(r).list_items; }
struct AMmapItems AMresultValueMapItems(AMresult *r) { return AMresultValue(r).map_items; }
const struct AMobjId *AMresultValueObjId(AMresult *r) { return AMresultValue(r).obj_id; }
struct AMobjItems AMresultValueObjItems(AMresult *r) { return AMresultValue(r).obj_items; }
const char *AMresultValueStr(AMresult *r) { return AMresultValue(r).str; }
struct AMstrs AMresultValueStrs(AMresult *r) { return AMresultValue(r).strs; }
const struct AMsyncMessage *AMresultValueSyncMessage(AMresult *r) { return AMresultValue(r).sync_message; }
struct AMsyncState *AMresultValueSyncState(AMresult *r) { return AMresultValue(r).sync_state; }
int64_t AMresultValueTimestamp(AMresult *r) { return AMresultValue(r).timestamp; }
uint64_t AMresultValueUint(AMresult *r) { return AMresultValue(r).uint; }
struct AMunknownValue AMresultValueUnknown(AMresult *r) { return AMresultValue(r).unknown; }
*/
import "C"
import (
	"fmt"
	"runtime"
	"time"
	"unsafe"

	"github.com/sasha-s/go-deadlock"
)

// Kind represents the underlying type of a Value
type Kind uint

var (
	// KindVoid indicates the value was not present
	KindVoid Kind = C.AM_VALUE_VOID
	// KindBool indicates a bool
	KindBool Kind = C.AM_VALUE_BOOLEAN
	// KindBytes indicates a []byte
	KindBytes Kind = C.AM_VALUE_BYTES
	// KindFloat64 indicates a float64
	KindFloat64 Kind = C.AM_VALUE_F64
	// KindInt indicates an int
	KindInt64 Kind = C.AM_VALUE_INT
	// KindUint indicates a uint
	KindUint64 Kind = C.AM_VALUE_UINT
	// KindNull indicates an explicit null was present
	KindNull Kind = C.AM_VALUE_NULL
	// KindStr indicates a string
	KindStr Kind = C.AM_VALUE_STR
	// KindTime indicates a time.Time
	KindTime Kind = C.AM_VALUE_TIMESTAMP

	// KindCounter indicates an *automerge.Counter
	KindCounter Kind = C.AM_VALUE_COUNTER
	// KindMap indicates an *automerge.Map
	KindMap Kind = C.AM_VALUE_MAP_ITEMS
	// KindList indicates an *automerge.List
	KindList Kind = C.AM_VALUE_LIST_ITEMS
	// KindText indicates an *automerge.Text
	KindText Kind = 1024
)

// ActorId identifies the "actor" who is modifying a document.
// Each operation applied to the document is identified by its
// actorId and a counter, so it is important that each actor
// generates a linear history of edits.
type ActorId struct {
	v *C.AMactorId
}

func (a *ActorId) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_ACTOR_ID {
		return fmt.Errorf("expected VALUE_ACTOR_ID, got %v", tag)
	}

	a.v = C.AMresultValueActorId(r)
	return nil
}

// NewActorId creates a new random actor id
func NewActorId() (*ActorId, error) {
	return call[*ActorId](C.AMactorIdInit())
}

// ActorIdFromString creates an actor id from a string.
// The string must be an even number of hex characters.
func ActorIdFromString(id string) (*ActorId, error) {
	cstr := C.CString(id)
	defer C.free(unsafe.Pointer(cstr))
	return call[*ActorId](C.AMactorIdInitStr(cstr))
}

// ActorIdFromBytes creates an actor id from those bytes
func ActorIdFromBytes(id []byte) (*ActorId, error) {
	cbytes := C.CBytes(id)
	defer C.free(cbytes)
	return call[*ActorId](C.AMactorIdInitBytes((*C.uchar)(cbytes), C.ulong(len(id))))
}

// Bytes returns the underlying bytes of the actor id
func (a *ActorId) Bytes() []byte {
	defer runtime.KeepAlive(a)
	ret := C.AMactorIdBytes(a.v)
	return C.GoBytes(unsafe.Pointer(ret.src), C.int(ret.count))
}

// String returns the hex-encoded form of the actor id bytes
func (a *ActorId) String() string {
	defer runtime.KeepAlive(a)
	return C.GoString(C.AMactorIdStr(a.v))
}

// Cmp returns 0 if the two actor ids are identical,
// -1 if a < b and 1 if b > a
func (a *ActorId) Cmp(b *ActorId) int {
	defer runtime.KeepAlive(a)
	defer runtime.KeepAlive(b)
	return int(C.AMactorIdCmp(a.v, b.v))
}

// Doc represents an automerge document
type Doc struct {
	cDoc *C.AMdoc

	m deadlock.Mutex
}

func (d *Doc) lock() (*C.AMdoc, func()) {
	d.m.Lock()
	locked := true
	return d.cDoc, func() {
		if locked {
			locked = false
			d.m.Unlock()
		}
	}
}

func (d *Doc) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_DOC {
		return fmt.Errorf("expected VALUE_DOC, got %v", tag)
	}

	d.cDoc = C.AMresultValueDoc(r)
	return nil
}

// New creates a new document from actorId. If actorId == nil then
// a new random actor id will be created.
func New(actorId *ActorId) (*Doc, error) {
	var a *C.AMactorId
	if actorId != nil {
		defer runtime.KeepAlive(actorId)
		a = actorId.v
	}

	return call[*Doc](C.AMcreate(a))
}

// Load loads a document from its serialized form
func Load(b []byte) (*Doc, error) {
	cbytes := C.CBytes(b)
	defer C.free(unsafe.Pointer(cbytes))

	return call[*Doc](C.AMload((*C.uchar)(cbytes), C.ulong(len(b))))
}

// Save exports a document to its serialized form
func (d *Doc) Save() ([]byte, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	b, err := call[*byteSpan](C.AMsave(cDoc))
	if err != nil {
		return nil, err
	}
	return b.bytes(), nil
}

// Root returns the root of the document as a Map
// for modification (use .Get() to get the value for reading)
func (d *Doc) Root() *Map {
	return &Map{doc: d, objId: &objId{v: (*C.AMobjId)(C.AM_ROOT)}}
}

// RootValue returns the root of the document as
// a Value with Kind() == KindMap
func (d *Doc) RootValue() *Value {
	return &Value{kind: KindMap, val: d.Root()}
}

// Path returns a [*Path] that points to a position in the doc.
// path will panic unless each path component is a string or an int.
// Passing no arguments to Path() returns a path pointing to the root of the
// document.
func (d *Doc) Path(path ...any) *Path {
	return (&Path{d: d}).Path(path...)
}

// Commit adds a new version to the document with all
// local changes so far.
func (d *Doc) Commit(msg string) (*ChangeHashes, error) {
	cstr := C.CString(msg)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMcommit(cDoc, cstr, nil))
}

// Heads returns the current heads for the document
func (d *Doc) Heads() (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMgetHeads(cDoc))
}

// Fork returns a new, independent, copy of the document
// if asOf == nil then it is forked in its current state.
// otherwise it returns a version as of the given Change Hashes.
func (d *Doc) Fork(asOf *ChangeHashes) (*Doc, error) {
	cDoc, unlock := d.lock()
	defer unlock()
	defer runtime.KeepAlive(asOf)

	if asOf == nil {
		return call[*Doc](C.AMfork(cDoc, nil))
	}

	return call[*Doc](C.AMfork(cDoc, &asOf.v))
}

// Merge extracts all changes from d2 that are not in d
// and then applies them to d.
func (d *Doc) Merge(d2 *Doc) (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	cDoc2, unlock2 := d2.lock()
	defer unlock2()

	return call[*ChangeHashes](C.AMmerge(cDoc, cDoc2))
}

// ActorId returns the current actorId of the doc.
func (d *Doc) ActorId() (*ActorId, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ActorId](C.AMgetActorId(cDoc))
}

// SetActorId updates the current actorId of the doc.
func (d *Doc) SetActorId(ai *ActorId) error {
	cDoc, unlock := d.lock()
	defer unlock()
	defer runtime.KeepAlive(ai)

	_, err := call[*void](C.AMsetActorId(cDoc, ai.v))
	return err
}

type byteSpan struct {
	v C.AMbyteSpan
}

func (bs *byteSpan) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_BYTES {
		return fmt.Errorf("expected VALUE_BYTES, got %v", tag)
	}

	bs.v = C.AMresultValueBytes(r)
	return nil
}

func (bs *byteSpan) bytes() []byte {
	return C.GoBytes(unsafe.Pointer(bs.v.src), C.int(bs.v.count))
}

type objId struct {
	r *C.AMresult
	v *C.AMobjId
}

func (o *objId) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_OBJ_ID {
		return fmt.Errorf("expected VALUE_OBJ_ID, got %v", tag)
	}

	o.r = r
	o.v = C.AMresultValueObjId(r)
	return nil
}

type void struct{}

func (*void) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_VOID {
		return fmt.Errorf("expected VALUE_VOID, got %v", tag)
	}

	return nil
}

// ChangeHashes are used to represent a version of the document
// This is done by returning a list of changeHashes because there is no
// fixed global ordering.
type ChangeHashes struct {
	v C.AMchangeHashes
}

func (ch *ChangeHashes) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_CHANGE_HASHES {
		return fmt.Errorf("expected VALUE_CHANGE_HASHES, got %v", tag)
	}
	ch.v = C.AMresultValueChangeHashes(r)
	return nil
}

// Cmp returns -1 if ch < ch2, 0 if they are equal and 1 if ch > ch2
func (ch *ChangeHashes) Cmp(ch2 *ChangeHashes) int {
	defer runtime.KeepAlive(ch)
	defer runtime.KeepAlive(ch2)

	return int(C.AMchangeHashesCmp(&ch.v, &ch2.v))
}

// Map is an automerge type that stores a map of strings to values
type Map struct {
	doc   *Doc
	objId *objId
	path  *Path
}

func (m *Map) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := m.doc.lock()
	return cDoc, m.objId.v, unlock
}

// NewMap returns a detached map.
// Before you can read from or write to it you must write it to the document.
func NewMap() *Map {
	return &Map{}
}

// Len returns the number of keys set in the map, or 0 on error
func (m *Map) Len() int {
	if m.objId == nil {
		if m.path == nil {
			return 0
		}
		m2, err := As[*List](m.path.Get())
		if err != nil {
			return 0
		}
		return m2.Len()
	}

	cDoc, cObj, unlock := m.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Set sets a key in the map to a given value.
// This method may error if the underlying operation errors,
// the type you provide cannot be converted to an automerge type,
// or if this is the first write to a Path.Map() and the path is not traverseable.
func (m *Map) Set(key string, value any) error {
	if m.objId == nil {
		if m.path == nil {
			return fmt.Errorf("automerge.Map: tried to write to detached map")
		}
		m2, err := m.path.ensureMap(key)
		if err != nil {
			return err
		}
		m.objId = m2.objId
	}

	cstr := C.CString(key)
	defer C.free(unsafe.Pointer(cstr))

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	value, err := normalize(value)
	if err != nil {
		return err
	}

	if value == nil {
		_, err := call[*void](C.AMmapPutNull(cDoc, cObj, cstr))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMmapPutBool(cDoc, cObj, cstr, C.bool(v)))
	case string:
		vstr := C.CString(v)
		defer C.free(unsafe.Pointer(vstr))
		_, err = call[*void](C.AMmapPutStr(cDoc, cObj, cstr, vstr))

	case []byte:
		vbytes := C.CBytes(v)
		defer C.free(vbytes)
		_, err = call[*void](C.AMmapPutBytes(cDoc, cObj, cstr, (*C.uchar)(vbytes), C.ulong(len(v))))

	case int64:
		_, err = call[*void](C.AMmapPutInt(cDoc, cObj, cstr, C.longlong(v)))

	case uint64:
		_, err = call[*void](C.AMmapPutUint(cDoc, cObj, cstr, C.ulonglong(v)))

	case float64:
		_, err = call[*void](C.AMmapPutF64(cDoc, cObj, cstr, C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMmapPutTimestamp(cDoc, cObj, cstr, C.longlong(v.UnixMilli())))

	case []any:
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		list := &List{doc: m.doc, objId: objId}
		unlock()
		return list.Append(v...)

	case map[string]any:
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		m := &Map{doc: m.doc, objId: objId}
		unlock()
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Map:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Map")
		}

		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		v.doc = m.doc
		v.objId = objId

	case *List:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.List")
		}

		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objId = objId

	case *Counter:
		if v.m != nil || v.l != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Counter")
		}

		_, err = call[*void](C.AMmapPutCounter(cDoc, cObj, cstr, C.longlong(v.val)))
		if err == nil {
			v.m = m
			v.key = key
		}

	case *Text:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Text")
		}
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objId = objId
		unlock()
		if err = v.Set(v.val); err != nil {
			return err
		}

	case *void:
		_, err = call[*void](C.AMmapDelete(cDoc, cObj, cstr))

	default:
		err = fmt.Errorf("automerge.Map: tried to write unsupported value %#v", value)
	}

	return err
}

// Del deletes a key and its corresponding value from the map
func (m *Map) Del(key string) error {
	return m.Set(key, &void{})
}

// Get retrieves the value from the map.
// This method will return an error if the underlying Get
// operation fails, or if this is the first attempt to access
// a Path.Map() and the path is not traverseable
func (m *Map) Get(key string) (*Value, error) {
	if m.objId == nil {
		if m.path == nil {
			return nil, fmt.Errorf("automerge.Map: tried to read detached map")
		}
		return m.path.Path(key).Get()
	}

	cstr := C.CString(key)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := m.lock()
	defer unlock()

	r := C.AMmapGet(cDoc, cObj, cstr, nil)
	unlock()
	v, err := createValue(m.doc, r)
	if err == nil && v.Kind() == KindCounter {
		c := v.Counter()
		c.m = m
		c.key = key
	}
	return v, err
}

// load loads the map into go values (recrusively)
func (m *Map) load() (map[string]any, error) {
	iter := m.Iter()

	ret := map[string]any{}

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

// Iter returns a MapItems to let you iterate over the contents of the Map.
// You must check for errors by calling [MapItems.Error]
func (m *Map) Iter() *MapItems {
	if m.objId == nil {
		if m.path == nil {
			return &MapItems{err: fmt.Errorf("automerge.Map: tried to read detached map")}
		}
		v, err := m.path.Get()
		if err != nil {
			return &MapItems{err: err}
		}
		if v.Kind() == KindMap {
			return v.Map().Iter()
		} else if v.Kind() == KindVoid {
			return &MapItems{}
		}
		return &MapItems{err: fmt.Errorf("%#v: tried to interate over non-map %#v", m.path, v.val)}
	}

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	iter, err := call[*MapItems](C.AMmapRange(cDoc, cObj, nil, nil, nil))
	if err != nil {
		return &MapItems{err: err}
	}
	iter.m = m
	return iter
}

// String returns a representation suitable for debugging.
func (m *Map) String() string {
	return m.GoString()
}

// GoString returns a representation suitable for debugging.
func (m *Map) GoString() string {
	iter := m.Iter()
	sofar := "&automerge.Map{"
	i := 0
	for {
		key, val, valid := iter.Next()
		if !valid {
			break
		}
		if i > 0 {
			sofar += ", "
		}
		i++
		sofar += fmt.Sprintf("%#v: ", key)
		if val.Kind() == KindMap {
			sofar += "&automerge.Map{...}"
		} else if val.Kind() == KindList {
			sofar += "&automerge.List{...}"
		} else {
			sofar += fmt.Sprintf("%#v", val.val)
		}

		if i >= 5 {
			sofar += ", ..."
			break
		}
	}

	if err := iter.Error(); err != nil {
		return "&automerge.Map{<error>}"
	}
	return sofar + "}"
}

// MapItems is an iterator over the contents of a Map
type MapItems struct {
	r *C.AMresult
	v C.AMmapItems
	m *Map

	err error
}

func (mi *MapItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_MAP_ITEMS {
		return fmt.Errorf("expected VALUE_MAP_ITEMS, got %v", tag)
	}

	mi.r = r
	mi.v = C.AMresultValueMapItems(r)
	return nil
}

// Next returns either the next key and value and true
// or "", nil, false to indicate that there are no more items
func (mi *MapItems) Next() (string, *Value, bool) {
	if mi.err != nil || mi.r == nil {
		return "", nil, false
	}
	defer runtime.KeepAlive(mi)

	item := C.AMmapItemsNext(&mi.v, 1)
	if item == nil {
		return "", nil, false
	}

	cKey := C.AMmapItemKey(item)
	key := C.GoString(cKey)

	// TODO: we should get the value from the mapItems instead to be concurrency safe.
	// but this requires a bunch of duplication to get values from map items.
	value, err := mi.m.Get(key)
	if err != nil {
		mi.err = err
		return "", nil, false
	}

	return key, value, true
}

// Error returns any error that occurred creating or using the iterator.
func (mi *MapItems) Error() error {
	return mi.err
}

type List struct {
	doc   *Doc
	objId *objId
	path  *Path
}

// NewList returns a detached list.
// Before you can read from or write to it you must write it to the document.
func NewList() *List {
	return &List{}
}

func (l *List) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := l.doc.lock()
	return cDoc, l.objId.v, unlock
}

func (l *List) load() ([]any, error) {
	iter := l.Iter()

	ret := make([]any, l.Len())

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

// Len returns the length of the list, or 0 on error
func (l *List) Len() int {
	if l.objId == nil {
		if l.path == nil {
			return 0
		}

		l, err := As[*List](l.path.Get())
		if err != nil {
			return 0
		}
		return l.Len()
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Iter returns a ListItems to let you iterate over the contents of the List.
// You must check for errors by calling [ListItems.Error]
func (l *List) Iter() *ListItems {
	if l.objId == nil {
		v, err := l.path.Get()
		if err != nil {
			return &ListItems{err: err}
		}
		if v.Kind() == KindList {
			return v.List().Iter()
		} else if v.Kind() == KindVoid {
			return &ListItems{}
		}
		return &ListItems{err: fmt.Errorf("%#v: tried to interate over non-list %#v", l.path, v.val)}
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	iter, err := call[*ListItems](C.AMlistRange(cDoc, cObj, 0, C.SIZE_MAX, nil))
	if err != nil {
		return &ListItems{err: err}
	}
	iter.l = l
	return iter
}

// Get returns the value at index i
func (l *List) Get(i int) (*Value, error) {
	if l.objId == nil {
		return l.path.Path(i).Get()
	}

	// make lists act more like maps
	if i >= l.Len() {
		return &Value{kind: KindVoid}, nil
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	r := C.AMlistGet(cDoc, cObj, C.ulong(i), nil)
	unlock()
	v, err := createValue(l.doc, r)
	if err != nil {
		return nil, err
	}
	if v.Kind() == KindCounter {
		c := v.Counter()
		c.l = l
		c.idx = i
	}
	return v, nil
}

// Append adds the values at the end of the list.
func (l *List) Append(values ...any) error {
	for _, v := range values {
		if err := l.put(C.SIZE_MAX, true, v); err != nil {
			return err
		}
	}
	return nil
}

// Set overwrites the value at l[idx] with value.
func (l *List) Set(idx int, value any) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}
	return l.put(C.ulong(idx), false, value)
}

// Insert inserts the new values just before idx.
func (l *List) Insert(idx int, value ...any) error {
	if idx < 0 || idx > l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}
	for i, v := range value {
		if err := l.put(C.ulong(idx+i), true, v); err != nil {
			return err
		}
	}
	return nil
}

// Delete removes the value at idx and shortens the list.
func (l *List) Delete(idx int) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	_, err := call[*void](C.AMlistDelete(cDoc, cObj, C.ulong(idx)))
	return err

}

// GoString returns a representation suitable for debugging.
func (l *List) GoString() string {
	iter := l.Iter()
	sofar := "&automerge.List{"
	i := 0
	for {
		_, val, valid := iter.Next()
		if !valid {
			break
		}
		if i > 0 {
			sofar += ", "
		}
		i++
		if val.Kind() == KindMap {
			sofar += "&automerge.Map{...}"
		} else if val.Kind() == KindList {
			sofar += "&automerge.List{...}"
		} else {
			sofar += fmt.Sprintf("%#v", val.val)
		}

		if i >= 5 {
			sofar += ", ..."
			break
		}
	}

	if err := iter.Error(); err != nil {
		return "&automerge.List{<error>}"
	}
	return sofar + "}"
}

func (l *List) put(i C.ulong, before bool, value any) error {
	if l.objId == nil {
		if l.path == nil {
			return fmt.Errorf("automerge.List: tried to write to detached list")
		}
		l2, err := l.path.ensureList(int(i))
		if err != nil {
			return err
		}
		l.objId = l2.objId
	}

	value, err := normalize(value)
	if err != nil {
		return err
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	if value == nil {
		_, err := call[*void](C.AMlistPutNull(cDoc, cObj, i, C.bool(before)))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMlistPutBool(cDoc, cObj, i, C.bool(before), C.bool(v)))
	case string:
		vstr := C.CString(v)
		defer C.free(unsafe.Pointer(vstr))
		_, err = call[*void](C.AMlistPutStr(cDoc, cObj, i, C.bool(before), vstr))

	case []byte:
		vbytes := C.CBytes(v)
		defer C.free(vbytes)
		_, err = call[*void](C.AMlistPutBytes(cDoc, cObj, i, C.bool(before), (*C.uchar)(vbytes), C.ulong(len(v))))

	case int64:
		_, err = call[*void](C.AMlistPutInt(cDoc, cObj, i, C.bool(before), C.longlong(v)))

	case uint64:
		_, err = call[*void](C.AMlistPutUint(cDoc, cObj, i, C.bool(before), C.ulonglong(v)))

	case float64:
		_, err = call[*void](C.AMlistPutF64(cDoc, cObj, i, C.bool(before), C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMlistPutTimestamp(cDoc, cObj, i, C.bool(before), C.longlong(v.UnixMilli())))

	case []any:
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		unlock()
		list := &List{doc: l.doc, objId: objId}
		return list.Append(v...)

	case map[string]any:
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		unlock()
		m := &Map{doc: l.doc, objId: objId}
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Counter:
		if v.m != nil || v.l != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Text")
		}

		_, err = call[*void](C.AMlistPutCounter(cDoc, cObj, i, C.bool(before), C.longlong(v.val)))
		if err == nil {
			v.l = l
			v.idx = int(i)
		}

	case *Text:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Text")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId
		unlock()
		if err := v.Set(v.val); err != nil {
			return err
		}

	case *Map:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Map")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId

	case *List:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.List")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId

	default:
		err = fmt.Errorf("automerge.List: tried to write unsupported value %#v", value)
	}

	return err
}

// ListItems is an iterator over the contents of a List
type ListItems struct {
	r *C.AMresult
	v C.AMlistItems
	l *List

	err error
}

func (li *ListItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_LIST_ITEMS {
		return fmt.Errorf("expected VALUE_LIST_ITEMS, got %v", tag)
	}

	li.r = r
	li.v = C.AMresultValueListItems(r)
	return nil
}

// Next returns either the next index and value and true
// or 0, nil, false to indicate that there are no more items
func (li *ListItems) Next() (int, *Value, bool) {
	if li.err != nil {
		return 0, nil, false
	}
	defer runtime.KeepAlive(li)

	item := C.AMlistItemsNext(&li.v, 1)
	if item == nil {
		return 0, nil, false
	}

	idx := C.AMlistItemIndex(item)

	value, err := li.l.Get(int(idx))
	if err != nil {
		li.err = err
		return 0, nil, false
	}

	return int(idx), value, true
}

// Error returns any error that occurred creating or using the iterator.
func (li *ListItems) Error() error {
	return li.err
}

// Counter is a mutable int64 that collaborators
// can increment or decrement.
type Counter struct {
	val int64

	path *Path

	m   *Map
	key string
	l   *List
	idx int
}

// NewCounter returns a detached counter with the given starting value.
// Before you can Get() or Inc() you must write it to the document.
func NewCounter(v int64) *Counter {
	return &Counter{val: v}
}

// Get returns the current value of the counter.
func (c *Counter) Get() (int64, error) {
	var v *Value
	var err error
	if c.m != nil {
		v, err = c.m.Get(c.key)
	} else if c.l != nil {
		v, err = c.l.Get(c.idx)
	} else if c.path != nil {
		v, err = c.path.Get()
	} else {
		return 0, fmt.Errorf("automerge.Counter: tried to read from detached counter")
	}
	if err != nil {
		return 0, err
	}

	if v.Kind() == KindVoid {
		return 0, nil
	}
	if v.Kind() == KindCounter {
		return v.Counter().val, nil
	}

	return 0, fmt.Errorf("automerge.Counter: tried to read non-counter %#v", v.val)
}

// Inc adjusts the counter by delta.
func (c *Counter) Inc(delta int64) error {
	if c.m == nil && c.l == nil {
		if c.path == nil {
			return fmt.Errorf("automerge.Counter: tried to write to detached counter")
		}

		c2, err := c.path.ensureCounter()
		if err != nil {
			return err
		}
		c.l = c2.l
		c.idx = c2.idx
		c.m = c2.m
		c.key = c2.key
	}

	if c.l != nil {
		cDoc, cObj, unlock := c.l.lock()
		defer unlock()
		_, err := call[*void](C.AMlistIncrement(cDoc, cObj, C.ulong(c.idx), C.longlong(delta)))
		return err
	}

	cstr := C.CString(c.key)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := c.m.lock()
	defer unlock()
	_, err := call[*void](C.AMmapIncrement(cDoc, cObj, cstr, C.longlong(delta)))
	return err
}

// GoString returns a representation suitable for debugging.
func (c *Counter) GoString() string {
	v, err := c.Get()
	if err != nil {
		return "&automerge.Counter(<error>)"
	}
	return fmt.Sprintf("&automerge.Counter(%v)", v)
}

// Text is a mutable string that can be edited collaboratively
type Text struct {
	doc   *Doc
	objId *objId
	path  *Path

	val string
}

func (t *Text) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := t.doc.lock()
	return cDoc, t.objId.v, unlock
}

// NewText returns a detached Text with the given starting value.
// Before you can read or write it you must write it to the document.
func NewText(s string) *Text {
	return &Text{val: s}
}

func (t *Text) Len() int {
	if t.objId == nil {
		if t.path == nil {
			return 0
		}
		l, err := As[*Text](t.path.Get())
		if err != nil {
			return 0
		}
		return l.Len()
	}

	cDoc, cObj, unlock := t.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Get returns the current value as a string
func (t *Text) Get() (string, error) {
	if t.objId == nil {
		if t.path == nil {
			return "", fmt.Errorf("automerge.Text: tried to read detached text")
		}
		v, err := t.path.Get()
		if err != nil {
			return "", err
		}
		if v.Kind() == KindVoid {
			return "", nil
		}
		if v.Kind() == KindText {
			return v.Text().Get()
		}
		return "", fmt.Errorf("automerge.Text: tried to read non-text value %#v", v.val)
	}

	cDoc, cObj, unlock := t.lock()
	defer unlock()

	us, err := call[*utf8String](C.AMtext(cDoc, cObj, nil))
	if err != nil {
		return "", err
	}
	return us.val, nil
}

// Set overwrites the entire string with a new value,
// prefer to use Insert/Del/Append/Splice as appropriate
// to make collaborative editing easier.
func (t *Text) Set(s string) error {
	return t.splice(0, C.SIZE_MAX, s)
}

// Insert adds a substr at position pos in the Text
func (t *Text) Insert(pos int, s string) error {
	return t.splice(C.ulong(pos), 0, s)
}

// Insert deletes del characters from position pos
func (t *Text) Delete(pos int, del int) error {
	return t.splice(C.ulong(pos), C.ulong(del), "")
}

// Append adds substr s at the end of the string
func (t *Text) Append(s string) error {
	return t.splice(C.SIZE_MAX, 0, s)
}

// Splice deletes del characters at position pos, and inserts
// substr s in their place.
func (t *Text) Splice(pos int, del int, s string) error {
	return t.splice(C.ulong(pos), C.ulong(del), s)
}

func (t *Text) splice(pos, del C.ulong, s string) error {
	if t.objId == nil {
		if t.path == nil {
			return fmt.Errorf("automerge.Text: tried to write to detached text")
		}
		t2, err := t.path.ensureText()
		if err != nil {
			return err
		}
		t.doc = t2.doc
		t.objId = t2.objId
	}

	cstr := C.CString(s)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := t.lock()
	defer unlock()

	_, err := call[*void](C.AMspliceText(cDoc, cObj, pos, del, cstr))
	if err != nil {
		return fmt.Errorf("automerge.Text: failed to write: %w", err)
	}
	return nil
}

// GoString returns a representation suitable for debugging.
func (t *Text) GoString() string {
	if t.objId == nil && t.path == nil {
		return fmt.Sprintf("&automerge.Text{%#v}", t.val)
	}
	v, err := t.Get()
	if err != nil {
		return "&automerge.Text{<error>}"
	}
	return fmt.Sprintf("&automerge.Text{%#v}", v)
}

type utf8String struct {
	val string
}

func (us *utf8String) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_STR {
		return fmt.Errorf("expected VALUE_STR, got %v", tag)
	}

	us.val = C.GoString(C.AMresultValueStr(r))
	return nil
}

// Value represents a dynamically typed value read from a document.
// It can hold any of the supported primative types (bool, string, []byte, float64, int64, uint64, time.Time)
// the four mutable types (*Map, *List, *Text, *Counter), or it can be an explicit null,
// or a void to indicate that no value existed at all.
// You can convert from a Value to a go type using [As], or call accessor methods directly.
type Value struct {
	kind Kind
	val  any
}

// init() takes responsibility for freeing r
func (v *Value) init(d *Doc, r *C.AMresult) error {
	tag := C.AMresultValueTag(r)

	if tag == C.AM_VALUE_OBJ_ID {
		return v.initObjId(d, r)
	}

	defer C.AMfree(r)

	v.kind = Kind(tag)
	switch v.kind {
	case KindBool:
		v.val = bool(C.AMresultValueBoolean(r))

	case KindNull, KindVoid:
		v.val = nil

	case KindStr:
		v.val = C.GoString(C.AMresultValueStr(r))

	case KindBytes:
		span := C.AMresultValueBytes(r)
		v.val = C.GoBytes(unsafe.Pointer(span.src), C.int(span.count))

	case KindFloat64:
		v.val = float64(C.AMresultValueF64(r))

	case KindInt64:
		v.val = int64(C.AMresultValueInt(r))

	case KindUint64:
		v.val = uint64(C.AMresultValueInt(r))

	case KindCounter:
		v.val = &Counter{val: int64(C.AMresultValueCounter(r))}

	case KindTime:
		v.val = time.UnixMilli(int64(C.AMresultValueTimestamp(r)))

	default:
		return fmt.Errorf("automerge.Value: unsupported kind %#v", v.kind)
	}

	return nil
}

// initObjId takes responsibliity for freeing r.
func (v *Value) initObjId(d *Doc, r *C.AMresult) error {
	o := &objId{r: r, v: C.AMresultValueObjId(r)}
	runtime.SetFinalizer(o, func(*objId) { C.AMfree(r) })

	cDoc, unlock := d.lock()
	defer unlock()

	switch C.AMobjObjType(cDoc, o.v) {
	case C.AM_OBJ_TYPE_LIST:
		v.kind = KindList
		v.val = &List{doc: d, objId: o}
	case C.AM_OBJ_TYPE_MAP:
		v.kind = KindMap
		v.val = &Map{doc: d, objId: o}
	case C.AM_OBJ_TYPE_TEXT:
		v.kind = KindText
		v.val = &Text{doc: d, objId: o}
	default:
		return fmt.Errorf("automerge.Value: unsupported object type %#v", C.AMobjObjType(d.cDoc, o.v))
	}

	return nil
}

func (v *Value) goValue() (any, error) {
	if v.kind == KindCounter {
		return v.Counter().Get()
	}
	if v.kind == KindText {
		return v.Text().Get()
	}
	if v.kind == KindList {
		return v.List().load()
	}
	if v.kind == KindMap {
		return v.Map().load()
	}
	return v.val, nil
}

// Kind reports the kind of the value
func (v *Value) Kind() Kind {
	return v.kind
}

// List returns the value as a [*List], it panics if Kind() != KindList
func (v *Value) List() *List {
	if v.kind != KindList {
		panic(fmt.Errorf("automerge.Value#List called on non-list: %#v", v))
	}
	return v.val.(*List)
}

// Map returns the value as a [*Map], it panics if Kind() != KindMap
func (v *Value) Map() *Map {
	if v.kind != KindMap {
		panic(fmt.Errorf("automerge.Value#Map called on non-map: %#v", v))
	}
	return v.val.(*Map)
}

// Counter returns the value as a [*Counter], it panics if Kind() != KindCounter
func (v *Value) Counter() *Counter {
	if v.kind != KindCounter {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Counter)
}

// Text returns the value as a [*Text], it panics if Kind() != KindText
func (v *Value) Text() *Text {
	if v.kind != KindText {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Text)
}

// Str returns the value as a string, it panics if Kind() != KindStr
func (v *Value) Str() string {
	if v.kind != KindStr {
		panic(fmt.Errorf("automerge.Value#Str called on non-string: %#v", v))
	}
	return v.val.(string)
}

// Bytes returns the value as a string, it panics if Kind() != KindBytes
func (v *Value) Bytes() []byte {
	if v.kind != KindBytes {
		panic(fmt.Errorf("automerge.Value#Bytes called on non-[]byte: %#v", v))
	}
	return v.val.([]byte)
}

// Bool returns the value as a bool, it panics if Kind() != KindBool
func (v *Value) Bool() bool {
	if v.kind != KindBool {
		panic(fmt.Errorf("automerge.Value#Bool called on non-bool: %#v", v))
	}
	return v.val.(bool)
}

// Float64 returns the value as a float64, it panics if Kind() != KindFloat64
func (v *Value) Float64() float64 {
	if v.kind != KindFloat64 {
		panic(fmt.Errorf("automerge.Value#Float64 called on non-float64: %#v", v))
	}
	return v.val.(float64)
}

// Int64 returns the value as a int64, it panics if Kind() != KindInt64
func (v *Value) Int64() int64 {
	if v.kind != KindInt64 {
		panic(fmt.Errorf("automerge.Value#Int64 called on non-int64: %#v", v))
	}
	return v.val.(int64)
}

// Uint64 returns the value as a uint64, it panics if Kind() != KindUint64
func (v *Value) Uint64() uint64 {
	if v.kind != KindUint64 {
		panic(fmt.Errorf("automerge.Value#Uint64 called on non-uint64: %#v", v))
	}
	return v.val.(uint64)
}

// Time returns the value as a time.Time, it panics if Kind() != KindTime
func (v *Value) Time() time.Time {
	if v.kind != KindTime {
		panic(fmt.Errorf("automerge.Value#Time called on non-time: %#v", v))
	}
	return v.val.(time.Time)
}

// IsVoid returns true if the value did not exist in the document
func (v *Value) IsVoid() bool {
	return v.kind == KindVoid
}

// IsNull returns true if the value is null
func (v *Value) IsNull() bool {
	return v.kind == KindNull
}

// GoString returns a representation suitable for debugging.
func (v *Value) GoString() string {
	if v.kind == KindVoid {
		return "&automerge.Value(<void>)"
	}
	return fmt.Sprintf("&automerge.Value(%#v)", v.val)
}

type initer interface {
	init(r *C.AMresult) error
}

func createValue(d *Doc, r *C.AMresult) (*Value, error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret := new(Value)
		err := ret.init(d, r)
		if err != nil {
			return nil, err
		}
		return ret, nil
	case C.AM_STATUS_ERROR:
		msg := C.GoString(C.AMerrorMessage(r))
		C.AMfree(r)
		return nil, fmt.Errorf(msg)
	case C.AM_STATUS_INVALID_RESULT:
		C.AMfree(r)
		return nil, fmt.Errorf("automerge: invalid result")
	default:
		C.AMfree(r)
		return nil, fmt.Errorf("automerge: invalid result status")
	}
}

func call[T interface {
	*X
	initer
}, X any](r *C.AMresult) (ret T, err error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret = T(new(X))
		err = ret.init(r)
	case C.AM_STATUS_ERROR:
		msg := C.GoString(C.AMerrorMessage(r))
		err = fmt.Errorf(msg)
	case C.AM_STATUS_INVALID_RESULT:
		err = fmt.Errorf("automerge: invalid result")
	default:
		err = fmt.Errorf("automerge: invalid result status")
	}

	if err != nil {
		C.AMfree(r)
		return nil, err
	}

	runtime.SetFinalizer(ret, func(ret T) { C.AMfree(r) })
	return ret, nil
}

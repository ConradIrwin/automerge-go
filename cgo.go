package automerge

//go:generate go run generate/gen.go

/*
#cgo LDFLAGS: -lautomerge
#cgo CFLAGS: -I${SRCDIR}/deps/include -Wall

#cgo darwin,arm64 LDFLAGS: -L${SRCDIR}/deps/darwin_arm64
#cgo darwin,amd64 LDFLAGS: -L${SRCDIR}/deps/darwin_amd64
#cgo linux,arm64 LDFLAGS: -L${SRCDIR}/deps/linux_arm64 -lm
#cgo linux,amd64 LDFLAGS: -L${SRCDIR}/deps/linux_amd64 -lm

#include "automerge.h"
#include <stdlib.h>

// The below is generated by `go run ./generate/gen.go`
// unions are not directly supported by cgo, so there are accessors for
// the various flavors of AMvalue either passing the AMresult

AMvalueVariant AMresultValueTag(AMresult *r) { return AMresultValue(r).tag; }
const struct AMactorId *AMresultValueActorId(AMresult *r) { return AMresultValue(r).actor_id; }
bool AMresultValueBoolean(AMresult *r) { return AMresultValue(r).boolean; }
struct AMbyteSpan AMresultValueBytes(AMresult *r) { return AMresultValue(r).bytes; }
struct AMchangeHashes AMresultValueChangeHashes(AMresult *r) { return AMresultValue(r).change_hashes; }
struct AMchanges AMresultValueChanges(AMresult *r) { return AMresultValue(r).changes; }
int64_t AMresultValueCounter(AMresult *r) { return AMresultValue(r).counter; }
struct AMdoc *AMresultValueDoc(AMresult *r) { return AMresultValue(r).doc; }
double AMresultValueF64(AMresult *r) { return AMresultValue(r).f64; }
int64_t AMresultValueInt(AMresult *r) { return AMresultValue(r).int_; }
struct AMlistItems AMresultValueListItems(AMresult *r) { return AMresultValue(r).list_items; }
struct AMmapItems AMresultValueMapItems(AMresult *r) { return AMresultValue(r).map_items; }
const struct AMobjId *AMresultValueObjId(AMresult *r) { return AMresultValue(r).obj_id; }
struct AMobjItems AMresultValueObjItems(AMresult *r) { return AMresultValue(r).obj_items; }
struct AMbyteSpan AMresultValueStr(AMresult *r) { return AMresultValue(r).str; }
struct AMstrs AMresultValueStrs(AMresult *r) { return AMresultValue(r).strs; }
const struct AMsyncMessage *AMresultValueSyncMessage(AMresult *r) { return AMresultValue(r).sync_message; }
struct AMsyncState *AMresultValueSyncState(AMresult *r) { return AMresultValue(r).sync_state; }
int64_t AMresultValueTimestamp(AMresult *r) { return AMresultValue(r).timestamp; }
uint64_t AMresultValueUint(AMresult *r) { return AMresultValue(r).uint; }
struct AMunknownValue AMresultValueUnknown(AMresult *r) { return AMresultValue(r).unknown; }
*/
import "C"
import (
	"encoding/hex"
	"fmt"
	"runtime"
	"sync"
	"time"
	"unsafe"
)

// Kind represents the underlying type of a Value
type Kind uint

var (
	// KindVoid indicates the value was not present
	KindVoid Kind = C.AM_VALUE_VOID
	// KindBool indicates a bool
	KindBool Kind = C.AM_VALUE_BOOLEAN
	// KindBytes indicates a []byte
	KindBytes Kind = C.AM_VALUE_BYTES
	// KindFloat64 indicates a float64
	KindFloat64 Kind = C.AM_VALUE_F64
	// KindInt indicates an int
	KindInt64 Kind = C.AM_VALUE_INT
	// KindUint indicates a uint
	KindUint64 Kind = C.AM_VALUE_UINT
	// KindNull indicates an explicit null was present
	KindNull Kind = C.AM_VALUE_NULL
	// KindStr indicates a string
	KindStr Kind = C.AM_VALUE_STR
	// KindTime indicates a time.Time
	KindTime Kind = C.AM_VALUE_TIMESTAMP
	// KindUnknown indicates an unknown type from a future version of automerge
	KindUnknown Kind = C.AM_VALUE_UNKNOWN

	// KindCounter indicates an *automerge.Counter
	KindCounter Kind = C.AM_VALUE_COUNTER
	// KindMap indicates an *automerge.Map
	KindMap Kind = C.AM_VALUE_MAP_ITEMS
	// KindList indicates an *automerge.List
	KindList Kind = C.AM_VALUE_LIST_ITEMS
	// KindText indicates an *automerge.Text
	KindText Kind = 1024
)

// ActorID identifies the "actor" who is modifying a document.
// Each operation applied to the document is identified by its
// actorId and a counter, so it is important that each actor
// generates a linear history of edits.
type ActorID struct {
	v *C.AMactorId
}

func (a *ActorID) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_ACTOR_ID {
		return fmt.Errorf("expected VALUE_ACTOR_ID, got %v", tag)
	}

	a.v = C.AMresultValueActorId(r)
	return nil
}

// NewActorID creates a new random actor id
func NewActorID() *ActorID {
	a, err := call[*ActorID](C.AMactorIdInit())
	// this call cannot error
	if err != nil {
		panic(err)
	}
	return a
}

// ActorIDFromString creates an actor id from a string.
// The string must be an even number of hex characters.
func ActorIDFromString(id string) (*ActorID, error) {
	cID, free := toByteSpanStr(id)
	defer free()
	return call[*ActorID](C.AMactorIdInitStr(cID))
}

// ActorIDFromBytes creates an actor id from those bytes
func ActorIDFromBytes(id []byte) (*ActorID, error) {
	cBytes, free := toByteSpan(id)
	defer free()
	return call[*ActorID](C.AMactorIdInitBytes(cBytes.src, cBytes.count))
}

// Bytes returns the underlying bytes of the actor id
func (a *ActorID) Bytes() []byte {
	defer runtime.KeepAlive(a)
	return fromByteSpan(C.AMactorIdBytes(a.v))
}

// String returns the hex-encoded form of the actor id bytes
func (a *ActorID) String() string {
	defer runtime.KeepAlive(a)
	return fromByteSpanStr(C.AMactorIdStr(a.v))
}

// Cmp returns 0 if the two actor ids are identical,
// -1 if a < b and 1 if b > a
func (a *ActorID) Cmp(b *ActorID) int {
	defer runtime.KeepAlive(a)
	defer runtime.KeepAlive(b)
	return int(C.AMactorIdCmp(a.v, b.v))
}

// Doc represents an automerge document
type Doc struct {
	cDoc *C.AMdoc

	m sync.Mutex
}

func (d *Doc) lock() (*C.AMdoc, func()) {
	d.m.Lock()
	locked := true
	return d.cDoc, func() {
		if locked {
			locked = false
			d.m.Unlock()
		}
	}
}

func (d *Doc) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_DOC {
		return fmt.Errorf("expected VALUE_DOC, got %v", tag)
	}

	d.cDoc = C.AMresultValueDoc(r)
	return nil
}

// New creates a new empty document with a randomly generated actorId.
func New() *Doc {
	d, err := call[*Doc](C.AMcreate(nil))
	// This call cannot error
	if err != nil {
		panic(err)
	}
	return d
}

// Load loads a document from its serialized form
func Load(b []byte) (*Doc, error) {
	cbytes, free := toByteSpan(b)
	defer free()

	return call[*Doc](C.AMload(cbytes.src, cbytes.count))
}

// Save exports a document to its serialized form
func (d *Doc) Save() ([]byte, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	b, err := call[*byteSpan](C.AMsave(cDoc))
	if err != nil {
		return nil, err
	}
	return b.bytes(), nil
}

// RootMap returns the root of the document as a Map
func (d *Doc) RootMap() *Map {
	return &Map{doc: d, objID: &objID{v: (*C.AMobjId)(C.AM_ROOT)}}
}

// Root returns the root of the document as
// a Value with Kind() == KindMap
func (d *Doc) Root() *Value {
	return &Value{kind: KindMap, val: d.RootMap()}
}

// Path returns a [*Path] that points to a position in the doc.
// path will panic unless each path component is a string or an int.
// Passing no arguments to Path() returns a path pointing to the root of the
// document.
func (d *Doc) Path(path ...any) *Path {
	return (&Path{d: d}).Path(path...)
}

// Commit adds a new version to the document with all
// local changes so far.
// The returned ChangeHashes contains a single hash representing the
// current state of the document.
func (d *Doc) Commit(msg string) (*ChangeHashes, error) {
	cMsg, free := toByteSpanStr(msg)
	defer free()

	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMcommit(cDoc, cMsg, nil))
}

// Heads returns the current heads for the document
func (d *Doc) Heads() (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMgetHeads(cDoc))
}

// Changes returns the Changes made to the doc since *ChangeHashes.
// If since is nil, returns all changes to recreate the document.
func (d *Doc) Changes(since *ChangeHashes) (*Changes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	if since == nil {
		return call[*Changes](C.AMgetChanges(cDoc, nil))
	}

	defer runtime.KeepAlive(since)
	return call[*Changes](C.AMgetChanges(cDoc, &since.v))
}

// Apply the given changes to the document
func (d *Doc) Apply(ch *Changes) error {
	defer runtime.KeepAlive(ch)
	cDoc, unlock := d.lock()
	defer unlock()

	_, err := call[*void](C.AMapplyChanges(cDoc, &ch.v))
	return err
}

// SaveIncremental exports the changes since the last call to [Doc.Save] or
// [Doc.SaveIncremental] for passing to [Doc.LoadIncremental] on a different doc.
// See also [SyncState] for a more managed approach to syncing.
func (d *Doc) SaveIncremental() ([]byte, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	b, err := call[*byteSpan](C.AMsaveIncremental(cDoc))
	if err != nil {
		return nil, err
	}

	return b.bytes(), nil
}

// LoadIncremental applies the changes exported by [Doc.SaveIncremental].
// It is the callers responsibility to ensure that every incremental change
// is applied to keep the documents in sync.
// See also [SyncState] for a more managed approach to syncing.
func (d *Doc) LoadIncremental(raw []byte) error {
	cDoc, unlock := d.lock()
	defer unlock()

	cBytes, free := toByteSpan(raw)
	defer free()

	_, err := call[*uintValue](C.AMloadIncremental(cDoc, cBytes.src, cBytes.count))
	return err
}

// Fork returns a new, independent, copy of the document
// if asOf == nil then it is forked in its current state.
// otherwise it returns a version as of the given Change Hashes.
func (d *Doc) Fork(asOf *ChangeHashes) (*Doc, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	if asOf == nil {
		return call[*Doc](C.AMfork(cDoc, nil))
	}

	defer runtime.KeepAlive(asOf)
	return call[*Doc](C.AMfork(cDoc, &asOf.v))
}

// Merge extracts all changes from d2 that are not in d
// and then applies them to d.
func (d *Doc) Merge(d2 *Doc) (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	cDoc2, unlock2 := d2.lock()
	defer unlock2()

	return call[*ChangeHashes](C.AMmerge(cDoc, cDoc2))
}

// ActorID returns the current actorId of the doc.
func (d *Doc) ActorID() (*ActorID, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ActorID](C.AMgetActorId(cDoc))
}

// SetActorID updates the current actorId of the doc.
func (d *Doc) SetActorID(ai *ActorID) error {
	cDoc, unlock := d.lock()
	defer unlock()
	defer runtime.KeepAlive(ai)

	_, err := call[*void](C.AMsetActorId(cDoc, ai.v))
	return err
}

func toByteSpan(b []byte) (C.AMbyteSpan, func()) {
	cBytes := C.CBytes(b)
	return C.AMbyteSpan{src: (*C.uchar)(cBytes), count: C.size_t(len(b))}, func() {
		C.free(cBytes)
	}
}
func fromByteSpan(bs C.AMbyteSpan) []byte {
	return C.GoBytes(unsafe.Pointer(bs.src), C.int(bs.count))
}

func toByteSpanStr(s string) (C.AMbyteSpan, func()) {
	return toByteSpan([]byte(s))
}

func fromByteSpanStr(bs C.AMbyteSpan) string {
	return string(fromByteSpan(bs))
}

type byteSpan struct {
	v C.AMbyteSpan
}

func (bs *byteSpan) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_BYTES {
		return fmt.Errorf("expected VALUE_BYTES, got %v", tag)
	}

	bs.v = C.AMresultValueBytes(r)
	return nil
}

func (bs *byteSpan) bytes() []byte {
	return fromByteSpan(bs.v)
}

type objID struct {
	r *C.AMresult
	v *C.AMobjId
}

func (o *objID) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_OBJ_ID {
		return fmt.Errorf("expected VALUE_OBJ_ID, got %v", tag)
	}

	o.r = r
	o.v = C.AMresultValueObjId(r)
	return nil
}

type void struct{}

func (*void) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_VOID {
		return fmt.Errorf("expected VALUE_VOID, got %v", tag)
	}

	return nil
}

type uintValue struct{ u uint64 }

func (uv *uintValue) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_UINT {
		return fmt.Errorf("expected VALUE_UINT, got %v", tag)
	}

	uv.u = uint64(C.AMresultValueUint(r))

	return nil
}

// Changes represent a set of changes applied to a doc
type Changes struct {
	v C.AMchanges
}

func (cs *Changes) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_CHANGES {
		return fmt.Errorf("expected VALUE_CHANGE_HASHES, got %v", tag)
	}
	cs.v = C.AMresultValueChanges(r)
	return nil
}

// LoadChanges loads Changes from bytes returned by [Changes.Save]
func LoadChanges(raw []byte) (*Changes, error) {
	cBytes, free := toByteSpan(raw)
	defer free()

	return call[*Changes](C.AMchangeLoadDocument(cBytes.src, cBytes.count))
}

// Save saves the Changes to bytes to be passed to [LoadChanges]
func (cs *Changes) Save() []byte {
	out := []byte{}

	cs2 := C.AMchangesRewound(&cs.v)
	defer runtime.KeepAlive(cs)
	for {
		c := C.AMchangesNext(&cs2, 1)
		if c == (*C.AMchange)(C.NULL) {
			break
		}

		b := C.AMchangeRawBytes(c)
		out = append(out, fromByteSpan(b)...)
	}
	return out
}

// ChangeHashes are used to represent a version of the document
// As automerge is a distributed protocol there may be many valid
// "most recent" changes, so this may be a list rather than a single hash.
type ChangeHashes struct {
	v C.AMchangeHashes
}

// NewChangeHashes initializes a ChangeHashes from a list of ChangeHash's
func NewChangeHashes(chs []ChangeHash) (*ChangeHashes, error) {
	panic("todo")
}

func (ch *ChangeHashes) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_CHANGE_HASHES {
		return fmt.Errorf("expected VALUE_CHANGE_HASHES, got %v", tag)
	}
	ch.v = C.AMresultValueChangeHashes(r)
	return nil
}

// Get returns the change hashes for further inspection
func (ch *ChangeHashes) Get() []ChangeHash {
	defer runtime.KeepAlive(ch)

	ch2 := C.AMchangeHashesRewound(&ch.v)
	defer runtime.KeepAlive(ch2)

	out := []ChangeHash{}

	for {
		b := C.AMchangeHashesNext(&ch2, 1)
		if b.src == (*C.uchar)(C.NULL) {
			break
		}
		out = append(out, ChangeHash(fromByteSpan(b)))
	}
	return out
}

// Cmp returns -1 if ch < ch2, 0 if they are equal and 1 if ch > ch2
func (ch *ChangeHashes) Cmp(ch2 *ChangeHashes) int {
	defer runtime.KeepAlive(ch)
	defer runtime.KeepAlive(ch2)

	return int(C.AMchangeHashesCmp(&ch.v, &ch2.v))
}

// ChangeHash is a hash of a change
type ChangeHash []byte

// String returns the hex-encoded form of the change hash
func (ch ChangeHash) String() string {
	return hex.EncodeToString([]byte(ch))
}

// NewChangeHash creates a change has from its hex representation.
func NewChangeHash(s string) (ChangeHash, error) {
	b, err := hex.DecodeString(s)
	if err != nil {
		return nil, err
	}
	return ChangeHash(b), nil
}

// Map is an automerge type that stores a map of strings to values
type Map struct {
	doc   *Doc
	objID *objID
	path  *Path
}

func (m *Map) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := m.doc.lock()
	return cDoc, m.objID.v, func() {
		runtime.KeepAlive(m)
		unlock()
	}
}

// NewMap returns a detached map.
// Before you can read from or write to it you must write it to the document.
func NewMap() *Map {
	return &Map{}
}

// Len returns the number of keys set in the map, or 0 on error
func (m *Map) Len() int {
	if m.objID == nil {
		if m.path == nil {
			return 0
		}
		m2, err := As[*Map](m.path.Get())
		if err != nil {
			return 0
		}
		return m2.Len()
	}

	cDoc, cObj, unlock := m.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Set sets a key in the map to a given value.
// This method may error if the underlying operation errors,
// the type you provide cannot be converted to an automerge type,
// or if this is the first write to a [Path.Map] and the path is not traverseable.
func (m *Map) Set(key string, value any) error {
	if m.objID == nil {
		if m.path == nil {
			return fmt.Errorf("automerge.Map: tried to write to detached map")
		}
		m2, err := m.path.ensureMap(key)
		if err != nil {
			return err
		}
		m.objID = m2.objID
	}

	cKey, free := toByteSpanStr(key)
	defer free()

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	value, err := normalize(value)
	if err != nil {
		return err
	}

	if value == nil {
		_, err := call[*void](C.AMmapPutNull(cDoc, cObj, cKey))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMmapPutBool(cDoc, cObj, cKey, C.bool(v)))
	case string:
		vStr, free := toByteSpanStr(v)
		defer free()
		_, err = call[*void](C.AMmapPutStr(cDoc, cObj, cKey, vStr))

	case []byte:
		vBytes, free := toByteSpan(v)
		defer free()
		_, err = call[*void](C.AMmapPutBytes(cDoc, cObj, cKey, vBytes))

	case int64:
		_, err = call[*void](C.AMmapPutInt(cDoc, cObj, cKey, C.int64_t(v)))

	case uint64:
		_, err = call[*void](C.AMmapPutUint(cDoc, cObj, cKey, C.uint64_t(v)))

	case float64:
		_, err = call[*void](C.AMmapPutF64(cDoc, cObj, cKey, C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMmapPutTimestamp(cDoc, cObj, cKey, C.int64_t(v.UnixMilli())))

	case []any:
		objID, err := call[*objID](C.AMmapPutObject(cDoc, cObj, cKey, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		list := &List{doc: m.doc, objID: objID}
		unlock()
		return list.Append(v...)

	case map[string]any:
		objID, err := call[*objID](C.AMmapPutObject(cDoc, cObj, cKey, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		m := &Map{doc: m.doc, objID: objID}
		unlock()
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Map:
		if v.objID != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Map")
		}

		objID, err := call[*objID](C.AMmapPutObject(cDoc, cObj, cKey, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		v.doc = m.doc
		v.objID = objID

	case *List:
		if v.objID != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.List")
		}

		objID, err := call[*objID](C.AMmapPutObject(cDoc, cObj, cKey, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objID = objID

	case *Counter:
		if v.m != nil || v.l != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Counter")
		}

		_, err = call[*void](C.AMmapPutCounter(cDoc, cObj, cKey, C.int64_t(v.val)))
		if err == nil {
			v.m = m
			v.key = key
		}

	case *Text:
		if v.objID != nil {
			return fmt.Errorf("automerge.Map: tried to move an existing *automerge.Text")
		}
		objID, err := call[*objID](C.AMmapPutObject(cDoc, cObj, cKey, C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objID = objID
		unlock()
		if err = v.Set(v.val); err != nil {
			return err
		}

	case *void:
		_, err = call[*void](C.AMmapDelete(cDoc, cObj, cKey))

	default:
		err = fmt.Errorf("automerge.Map: tried to write unsupported value %#v", value)
	}

	return err
}

// Del deletes a key and its corresponding value from the map
func (m *Map) Del(key string) error {
	return m.Set(key, &void{})
}

// Keys returns the current list of keys for the map
func (m *Map) Keys() ([]string, error) {
	i := m.Iter()
	out := []string{}
	for {
		k, _, valid := i.Next()
		if !valid {
			break
		}
		out = append(out, k)
	}
	if i.Error() != nil {
		return nil, i.Error()
	}
	return out, nil
}

// Get retrieves the value from the map.
// This method will return an error if the underlying Get
// operation fails, or if this is the first attempt to access
// a Path.Map() and the path is not traverseable
func (m *Map) Get(key string) (*Value, error) {
	if m.objID == nil {
		if m.path == nil {
			return nil, fmt.Errorf("automerge.Map: tried to read detached map")
		}
		return m.path.Path(key).Get()
	}

	cKey, free := toByteSpanStr(key)
	defer free()
	cDoc, cObj, unlock := m.lock()
	defer unlock()

	r := C.AMmapGet(cDoc, cObj, cKey, nil)
	unlock()
	v, err := createValue(m.doc, r)
	if err == nil && v.Kind() == KindCounter {
		c := v.Counter()
		c.m = m
		c.key = key
	}
	return v, err
}

// load loads the map into go values (recrusively)
func (m *Map) load() (map[string]any, error) {
	iter := m.Iter()

	ret := map[string]any{}

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

// Iter returns a MapItems to let you iterate over the contents of the Map.
// You must check for errors by calling [MapItems.Error]
func (m *Map) Iter() *MapItems {
	if m.objID == nil {
		if m.path == nil {
			return &MapItems{err: fmt.Errorf("automerge.Map: tried to read detached map")}
		}
		v, err := m.path.Get()
		if err != nil {
			return &MapItems{err: err}
		}
		if v.Kind() == KindMap {
			return v.Map().Iter()
		} else if v.Kind() == KindVoid {
			return &MapItems{}
		}
		return &MapItems{err: fmt.Errorf("%#v: tried to interate over non-map %#v", m.path, v.val)}
	}

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	iter, err := call[*MapItems](C.AMmapRange(cDoc, cObj, C.AMstr(nil), C.AMstr(nil), nil))
	if err != nil {
		return &MapItems{err: err}
	}
	iter.m = m
	return iter
}

// GoString returns a representation suitable for debugging.
func (m *Map) GoString() string {
	if m.objID == nil {
		return "&automerge.Map{}"
	}
	iter := m.Iter()
	sofar := "&automerge.Map{"
	i := 0
	for {
		key, val, valid := iter.Next()
		if !valid {
			break
		}
		if i > 0 {
			sofar += ", "
		}
		i++
		sofar += fmt.Sprintf("%#v: ", key)
		if val.Kind() == KindMap {
			sofar += "&automerge.Map{...}"
		} else if val.Kind() == KindList {
			sofar += "&automerge.List{...}"
		} else {
			sofar += fmt.Sprintf("%#v", val.val)
		}

		if i >= 5 {
			sofar += ", ..."
			break
		}
	}

	if err := iter.Error(); err != nil {
		return "&automerge.Map{<error>}"
	}
	return sofar + "}"
}

// MapItems is an iterator over the contents of a Map
type MapItems struct {
	r *C.AMresult
	v C.AMmapItems
	m *Map

	err error
}

func (mi *MapItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_MAP_ITEMS {
		return fmt.Errorf("expected VALUE_MAP_ITEMS, got %v", tag)
	}

	mi.r = r
	mi.v = C.AMresultValueMapItems(r)
	return nil
}

// Next returns either the next key and value and true
// or "", nil, false to indicate that there are no more items
func (mi *MapItems) Next() (string, *Value, bool) {
	if mi.err != nil || mi.r == nil {
		return "", nil, false
	}
	defer runtime.KeepAlive(mi)

	item := C.AMmapItemsNext(&mi.v, 1)
	if item == nil {
		return "", nil, false
	}

	cKey := C.AMmapItemKey(item)
	key := fromByteSpanStr(cKey)

	// TODO: we should get the value from the mapItems instead to be concurrency safe.
	// but this requires a bunch of duplication to get values from map items.
	value, err := mi.m.Get(key)
	if err != nil {
		mi.err = err
		return "", nil, false
	}

	return key, value, true
}

// Error returns any error that occurred creating or using the iterator.
func (mi *MapItems) Error() error {
	return mi.err
}

type List struct {
	doc   *Doc
	objID *objID
	path  *Path
}

// NewList returns a detached list.
// Before you can read from or write to it you must write it to the document.
func NewList() *List {
	return &List{}
}

func (l *List) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := l.doc.lock()
	return cDoc, l.objID.v, func() {
		runtime.KeepAlive(l)
		unlock()
	}
}

func (l *List) load() ([]any, error) {
	iter := l.Iter()

	ret := make([]any, l.Len())

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

// Len returns the length of the list, or 0 on error
func (l *List) Len() int {
	if l.objID == nil {
		if l.path == nil {
			return 0
		}

		l, err := As[*List](l.path.Get())
		if err != nil {
			return 0
		}
		return l.Len()
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Iter returns a ListItems to let you iterate over the contents of the List.
// You must check for errors by calling [ListItems.Error]
func (l *List) Iter() *ListItems {
	if l.objID == nil {
		v, err := l.path.Get()
		if err != nil {
			return &ListItems{err: err}
		}
		if v.Kind() == KindList {
			return v.List().Iter()
		} else if v.Kind() == KindVoid {
			return &ListItems{}
		}
		return &ListItems{err: fmt.Errorf("%#v: tried to interate over non-list %#v", l.path, v.val)}
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	iter, err := call[*ListItems](C.AMlistRange(cDoc, cObj, 0, C.SIZE_MAX, nil))
	if err != nil {
		return &ListItems{err: err}
	}
	iter.l = l
	return iter
}

// Get returns the value at index i
func (l *List) Get(i int) (*Value, error) {
	if l.objID == nil {
		return l.path.Path(i).Get()
	}

	// make lists act more like maps
	if i >= l.Len() {
		return &Value{kind: KindVoid}, nil
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	r := C.AMlistGet(cDoc, cObj, C.size_t(i), nil)
	unlock()
	v, err := createValue(l.doc, r)
	if err != nil {
		return nil, err
	}
	if v.Kind() == KindCounter {
		c := v.Counter()
		c.l = l
		c.idx = i
	}
	return v, nil
}

// Append adds the values at the end of the list.
func (l *List) Append(values ...any) error {
	for _, v := range values {
		if err := l.put(C.SIZE_MAX, true, v); err != nil {
			return err
		}
	}
	return nil
}

// Set overwrites the value at l[idx] with value.
func (l *List) Set(idx int, value any) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}
	return l.put(C.size_t(idx), false, value)
}

// Insert inserts the new values just before idx.
func (l *List) Insert(idx int, value ...any) error {
	if idx < 0 || idx > l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}
	for i, v := range value {
		if err := l.put(C.size_t(idx+i), true, v); err != nil {
			return err
		}
	}
	return nil
}

// Delete removes the value at idx and shortens the list.
func (l *List) Delete(idx int) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge.List: tried to write index %v beyond end of list length %v", idx, l.Len())
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	_, err := call[*void](C.AMlistDelete(cDoc, cObj, C.size_t(idx)))
	return err

}

// GoString returns a representation suitable for debugging.
func (l *List) GoString() string {
	if l.objID == nil {
		return "&automerge.Map{}"
	}
	iter := l.Iter()
	sofar := "&automerge.List{"
	i := 0
	for {
		_, val, valid := iter.Next()
		if !valid {
			break
		}
		if i > 0 {
			sofar += ", "
		}
		i++
		if val.Kind() == KindMap {
			sofar += "&automerge.Map{...}"
		} else if val.Kind() == KindList {
			sofar += "&automerge.List{...}"
		} else {
			sofar += fmt.Sprintf("%#v", val.val)
		}

		if i >= 5 {
			sofar += ", ..."
			break
		}
	}

	if err := iter.Error(); err != nil {
		return "&automerge.List{<error>}"
	}
	return sofar + "}"
}

func (l *List) put(i C.size_t, before bool, value any) error {
	if l.objID == nil {
		if l.path == nil {
			return fmt.Errorf("automerge.List: tried to write to detached list")
		}
		l2, err := l.path.ensureList(int(i))
		if err != nil {
			return err
		}
		l.objID = l2.objID
	}

	value, err := normalize(value)
	if err != nil {
		return err
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	if value == nil {
		_, err := call[*void](C.AMlistPutNull(cDoc, cObj, i, C.bool(before)))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMlistPutBool(cDoc, cObj, i, C.bool(before), C.bool(v)))
	case string:
		vStr, free := toByteSpanStr(v)
		defer free()
		_, err = call[*void](C.AMlistPutStr(cDoc, cObj, i, C.bool(before), vStr))

	case []byte:
		vBytes, free := toByteSpan(v)
		defer free()
		_, err = call[*void](C.AMlistPutBytes(cDoc, cObj, i, C.bool(before), vBytes))

	case int64:
		_, err = call[*void](C.AMlistPutInt(cDoc, cObj, i, C.bool(before), C.int64_t(v)))

	case uint64:
		_, err = call[*void](C.AMlistPutUint(cDoc, cObj, i, C.bool(before), C.uint64_t(v)))

	case float64:
		_, err = call[*void](C.AMlistPutF64(cDoc, cObj, i, C.bool(before), C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMlistPutTimestamp(cDoc, cObj, i, C.bool(before), C.int64_t(v.UnixMilli())))

	case []any:
		objID, err := call[*objID](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		unlock()
		list := &List{doc: l.doc, objID: objID}
		return list.Append(v...)

	case map[string]any:
		objID, err := call[*objID](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		unlock()
		m := &Map{doc: l.doc, objID: objID}
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Counter:
		if v.m != nil || v.l != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Text")
		}

		_, err = call[*void](C.AMlistPutCounter(cDoc, cObj, i, C.bool(before), C.int64_t(v.val)))
		if err == nil {
			v.l = l
			v.idx = int(i)
		}

	case *Text:
		if v.objID != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Text")
		}
		objID, err := call[*objID](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objID = objID
		unlock()
		if err := v.Set(v.val); err != nil {
			return err
		}

	case *Map:
		if v.objID != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.Map")
		}
		objID, err := call[*objID](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objID = objID

	case *List:
		if v.objID != nil {
			return fmt.Errorf("automerge.List: tried to move an attached *automerge.List")
		}
		objID, err := call[*objID](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objID = objID

	default:
		err = fmt.Errorf("automerge.List: tried to write unsupported value %#v", value)
	}

	return err
}

// ListItems is an iterator over the contents of a List
type ListItems struct {
	r *C.AMresult
	v C.AMlistItems
	l *List

	err error
}

func (li *ListItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_LIST_ITEMS {
		return fmt.Errorf("expected VALUE_LIST_ITEMS, got %v", tag)
	}

	li.r = r
	li.v = C.AMresultValueListItems(r)
	return nil
}

// Next returns either the next index and value and true
// or 0, nil, false to indicate that there are no more items
func (li *ListItems) Next() (int, *Value, bool) {
	if li.err != nil {
		return 0, nil, false
	}
	defer runtime.KeepAlive(li)

	item := C.AMlistItemsNext(&li.v, 1)
	if item == nil {
		return 0, nil, false
	}

	idx := C.AMlistItemIndex(item)

	value, err := li.l.Get(int(idx))
	if err != nil {
		li.err = err
		return 0, nil, false
	}

	return int(idx), value, true
}

// Error returns any error that occurred creating or using the iterator.
func (li *ListItems) Error() error {
	return li.err
}

// Counter is a mutable int64 that collaborators
// can increment or decrement.
type Counter struct {
	val int64

	path *Path

	m   *Map
	key string
	l   *List
	idx int
}

// NewCounter returns a detached counter with the given starting value.
// Before you can Get() or Inc() you must write it to the document.
func NewCounter(v int64) *Counter {
	return &Counter{val: v}
}

// Get returns the current value of the counter.
func (c *Counter) Get() (int64, error) {
	var v *Value
	var err error
	if c.m != nil {
		v, err = c.m.Get(c.key)
	} else if c.l != nil {
		v, err = c.l.Get(c.idx)
	} else if c.path != nil {
		v, err = c.path.Get()
	} else {
		return 0, fmt.Errorf("automerge.Counter: tried to read from detached counter")
	}
	if err != nil {
		return 0, err
	}

	if v.Kind() == KindVoid {
		return 0, nil
	}
	if v.Kind() == KindCounter {
		return v.Counter().val, nil
	}

	return 0, fmt.Errorf("automerge.Counter: tried to read non-counter %#v", v.val)
}

// Inc adjusts the counter by delta.
func (c *Counter) Inc(delta int64) error {
	if c.m == nil && c.l == nil {
		if c.path == nil {
			return fmt.Errorf("automerge.Counter: tried to write to detached counter")
		}

		c2, err := c.path.ensureCounter()
		if err != nil {
			return err
		}
		c.l = c2.l
		c.idx = c2.idx
		c.m = c2.m
		c.key = c2.key
	}

	if c.l != nil {
		cDoc, cObj, unlock := c.l.lock()
		defer unlock()
		_, err := call[*void](C.AMlistIncrement(cDoc, cObj, C.size_t(c.idx), C.int64_t(delta)))
		return err
	}

	cKey, free := toByteSpanStr(c.key)
	defer free()
	cDoc, cObj, unlock := c.m.lock()
	defer unlock()
	_, err := call[*void](C.AMmapIncrement(cDoc, cObj, cKey, C.int64_t(delta)))
	return err
}

// GoString returns a representation suitable for debugging.
func (c *Counter) GoString() string {
	if c.l == nil && c.m == nil {
		return fmt.Sprintf("&automerge.Counter{%v}", c.val)
	}
	v, err := c.Get()
	if err != nil {
		return "&automerge.Counter{<error>}"
	}
	return fmt.Sprintf("&automerge.Counter{%v}", v)
}

// Text is a mutable string that can be edited collaboratively
type Text struct {
	doc   *Doc
	objID *objID
	path  *Path

	val string
}

func (t *Text) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := t.doc.lock()
	return cDoc, t.objID.v, unlock
}

// NewText returns a detached Text with the given starting value.
// Before you can read or write it you must write it to the document.
func NewText(s string) *Text {
	return &Text{val: s}
}

func (t *Text) Len() int {
	if t.objID == nil {
		if t.path == nil {
			return 0
		}
		l, err := As[*Text](t.path.Get())
		if err != nil {
			return 0
		}
		return l.Len()
	}

	cDoc, cObj, unlock := t.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

// Get returns the current value as a string
func (t *Text) Get() (string, error) {
	if t.objID == nil {
		if t.path == nil {
			return "", fmt.Errorf("automerge.Text: tried to read detached text")
		}
		v, err := t.path.Get()
		if err != nil {
			return "", err
		}
		if v.Kind() == KindVoid {
			return "", nil
		}
		if v.Kind() == KindText {
			return v.Text().Get()
		}
		return "", fmt.Errorf("automerge.Text: tried to read non-text value %#v", v.val)
	}

	cDoc, cObj, unlock := t.lock()
	defer unlock()

	us, err := call[*utf8String](C.AMtext(cDoc, cObj, nil))
	if err != nil {
		return "", err
	}
	return us.val, nil
}

// Set overwrites the entire string with a new value,
// prefer to use Insert/Del/Append/Splice as appropriate
// to make collaborative editing easier.
func (t *Text) Set(s string) error {
	return t.splice(0, C.SIZE_MAX, s)
}

// Insert adds a substr at position pos in the Text
func (t *Text) Insert(pos int, s string) error {
	return t.splice(C.size_t(pos), 0, s)
}

// Delete deletes del characters from position pos
func (t *Text) Delete(pos int, del int) error {
	return t.splice(C.size_t(pos), C.size_t(del), "")
}

// Append adds substr s at the end of the string
func (t *Text) Append(s string) error {
	return t.splice(C.SIZE_MAX, 0, s)
}

// Splice deletes del characters at position pos, and inserts
// substr s in their place.
func (t *Text) Splice(pos int, del int, s string) error {
	return t.splice(C.size_t(pos), C.size_t(del), s)
}

func (t *Text) splice(pos, del C.size_t, s string) error {
	if t.objID == nil {
		if t.path == nil {
			return fmt.Errorf("automerge.Text: tried to write to detached text")
		}
		t2, err := t.path.ensureText()
		if err != nil {
			return err
		}
		t.doc = t2.doc
		t.objID = t2.objID
	}

	cStr, free := toByteSpanStr(s)
	defer free()
	cDoc, cObj, unlock := t.lock()
	defer unlock()

	_, err := call[*void](C.AMspliceText(cDoc, cObj, pos, del, cStr))
	if err != nil {
		return fmt.Errorf("automerge.Text: failed to write: %w", err)
	}
	return nil
}

// GoString returns a representation suitable for debugging.
func (t *Text) GoString() string {
	if t.objID == nil && t.path == nil {
		return fmt.Sprintf("&automerge.Text{%#v}", t.val)
	}
	v, err := t.Get()
	if err != nil {
		return "&automerge.Text{<error>}"
	}
	return fmt.Sprintf("&automerge.Text{%#v}", v)
}

type utf8String struct {
	val string
}

func (us *utf8String) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_STR {
		return fmt.Errorf("expected VALUE_STR, got %v", tag)
	}

	us.val = fromByteSpanStr(C.AMresultValueStr(r))
	return nil
}

// SyncState represents the state of syncing between a local copy of
// a doc and a peer; and lets you optimize bandwidth used to ensure
// two docs are always in sync.
type SyncState struct {
	doc *Doc
	val *C.AMsyncState
}

func (ss *SyncState) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_SYNC_STATE {
		return fmt.Errorf("expected VALUE_SYNC_STATE, got %v", tag)
	}

	ss.val = C.AMresultValueSyncState(r)
	return nil
}

// NewSyncState returns a new sync state to sync with a peer
func NewSyncState(d *Doc) *SyncState {
	ss, err := call[*SyncState](C.AMsyncStateInit())
	// This call cannot error
	if err != nil {
		panic(err)
	}
	ss.doc = d
	return ss
}

// LoadSyncState lets you resume syncing with a peer from where you left off.
func LoadSyncState(d *Doc, raw []byte) (*SyncState, error) {
	cBytes, free := toByteSpan(raw)
	defer free()

	ss, err := call[*SyncState](C.AMsyncStateDecode(cBytes.src, cBytes.count))
	if err != nil {
		return nil, err
	}
	ss.doc = d
	return ss, err
}

// ReceiveMessage should be called with every message created by GenerateMessage
// on the peer side.
func (ss *SyncState) ReceiveMessage(msg []byte) error {

	sm, err := loadSyncMessage(msg)
	if err != nil {
		return err
	}

	defer runtime.KeepAlive(ss)
	defer runtime.KeepAlive(sm)
	cDoc, unlock := ss.doc.lock()
	defer unlock()

	_, err = call[*void](C.AMreceiveSyncMessage(cDoc, ss.val, sm.v))
	return err
}

// GenerateMessage generates the next message to send to the client.
// If `valid` is false the clients are currently in sync and there are
// no more messages to send (until you either modify the underlying document)
func (ss *SyncState) GenerateMessage() (bytes []byte, valid bool, err error) {
	defer runtime.KeepAlive(ss)
	cDoc, unlock := ss.doc.lock()
	defer unlock()

	sm, err := call[*syncMessage](C.AMgenerateSyncMessage(cDoc, ss.val))

	if err != nil {
		return nil, false, err
	}
	if !sm.valid {
		return nil, false, nil
	}

	b, err := sm.save()
	if err != nil {
		return nil, false, err
	}
	return b, true, nil
}

// Save serializes the sync state so that you can resume it later.
// This is an optimization to reduce the number of round-trips required
// to get two peers in sync at a later date.
func (ss *SyncState) Save() ([]byte, error) {
	defer runtime.KeepAlive(ss)

	b, err := call[*byteSpan](C.AMsyncStateEncode(ss.val))
	if err != nil {
		return nil, err
	}
	return b.bytes(), nil
}

type syncMessage struct {
	valid bool
	v     *C.AMsyncMessage
}

func (sm *syncMessage) init(r *C.AMresult) error {
	tag := C.AMresultValueTag(r)
	if tag == C.AM_VALUE_VOID {
		return nil
	}

	if tag != C.AM_VALUE_SYNC_MESSAGE {
		return fmt.Errorf("expected VALUE_SYNC_STATE, got %v", tag)
	}

	sm.valid = true
	sm.v = C.AMresultValueSyncMessage(r)
	return nil

}

func loadSyncMessage(msg []byte) (*syncMessage, error) {
	cBytes, free := toByteSpan(msg)
	defer free()

	return call[*syncMessage](C.AMsyncMessageDecode(cBytes.src, cBytes.count))
}

func (sm *syncMessage) save() ([]byte, error) {
	if !sm.valid {
		return nil, nil
	}
	defer runtime.KeepAlive(sm)
	b, err := call[*byteSpan](C.AMsyncMessageEncode(sm.v))
	if err != nil {
		return nil, err
	}
	return b.bytes(), nil
}

// Value represents a dynamically typed value read from a document.
// It can hold any of the supported primative types (bool, string, []byte, float64, int64, uint64, time.Time)
// the four mutable types (*Map, *List, *Text, *Counter), or it can be an explicit null,
// or a void to indicate that no value existed at all.
// You can convert from a Value to a go type using [As], or call accessor methods directly.
type Value struct {
	kind Kind
	val  any
}

// init() takes responsibility for freeing r
func (v *Value) init(d *Doc, r *C.AMresult) error {
	tag := C.AMresultValueTag(r)

	if tag == C.AM_VALUE_OBJ_ID {
		return v.initObjID(d, r)
	}

	defer C.AMfree(r)

	v.kind = Kind(tag)
	switch v.kind {
	case KindBool:
		v.val = bool(C.AMresultValueBoolean(r))

	case KindNull, KindVoid:
		v.val = nil

	case KindStr:
		v.val = fromByteSpanStr(C.AMresultValueStr(r))

	case KindBytes:
		v.val = fromByteSpan(C.AMresultValueBytes(r))

	case KindFloat64:
		v.val = float64(C.AMresultValueF64(r))

	case KindInt64:
		v.val = int64(C.AMresultValueInt(r))

	case KindUint64:
		v.val = uint64(C.AMresultValueInt(r))

	case KindCounter:
		v.val = &Counter{val: int64(C.AMresultValueCounter(r))}

	case KindTime:
		v.val = time.UnixMilli(int64(C.AMresultValueTimestamp(r)))

	case KindUnknown:
		v.val = nil

	default:
		return fmt.Errorf("automerge.Value: unsupported kind %#v", v.kind)
	}

	return nil
}

// initObjID takes responsibliity for freeing r.
func (v *Value) initObjID(d *Doc, r *C.AMresult) error {
	o := &objID{r: r, v: C.AMresultValueObjId(r)}
	runtime.SetFinalizer(o, func(*objID) { C.AMfree(r) })

	cDoc, unlock := d.lock()
	defer unlock()

	switch C.AMobjObjType(cDoc, o.v) {
	case C.AM_OBJ_TYPE_LIST:
		v.kind = KindList
		v.val = &List{doc: d, objID: o}
	case C.AM_OBJ_TYPE_MAP:
		v.kind = KindMap
		v.val = &Map{doc: d, objID: o}
	case C.AM_OBJ_TYPE_TEXT:
		v.kind = KindText
		v.val = &Text{doc: d, objID: o}
	default:
		return fmt.Errorf("automerge.Value: unsupported object type %#v", C.AMobjObjType(d.cDoc, o.v))
	}

	return nil
}

func (v *Value) goValue() (any, error) {
	if v.kind == KindCounter {
		return v.Counter().Get()
	}
	if v.kind == KindText {
		return v.Text().Get()
	}
	if v.kind == KindList {
		return v.List().load()
	}
	if v.kind == KindMap {
		return v.Map().load()
	}
	return v.val, nil
}

// Kind reports the kind of the value
func (v *Value) Kind() Kind {
	return v.kind
}

// List returns the value as a [*List], it panics if Kind() != KindList
func (v *Value) List() *List {
	if v.kind != KindList {
		panic(fmt.Errorf("automerge.Value#List called on non-list: %#v", v))
	}
	return v.val.(*List)
}

// Map returns the value as a [*Map], it panics if Kind() != KindMap
func (v *Value) Map() *Map {
	if v.kind != KindMap {
		panic(fmt.Errorf("automerge.Value#Map called on non-map: %#v", v))
	}
	return v.val.(*Map)
}

// Counter returns the value as a [*Counter], it panics if Kind() != KindCounter
func (v *Value) Counter() *Counter {
	if v.kind != KindCounter {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Counter)
}

// Text returns the value as a [*Text], it panics if Kind() != KindText
func (v *Value) Text() *Text {
	if v.kind != KindText {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Text)
}

// Str returns the value as a string, it panics if Kind() != KindStr
func (v *Value) Str() string {
	if v.kind != KindStr {
		panic(fmt.Errorf("automerge.Value#Str called on non-string: %#v", v))
	}
	return v.val.(string)
}

// Bytes returns the value as a string, it panics if Kind() != KindBytes
func (v *Value) Bytes() []byte {
	if v.kind != KindBytes {
		panic(fmt.Errorf("automerge.Value#Bytes called on non-[]byte: %#v", v))
	}
	return v.val.([]byte)
}

// Bool returns the value as a bool, it panics if Kind() != KindBool
func (v *Value) Bool() bool {
	if v.kind != KindBool {
		panic(fmt.Errorf("automerge.Value#Bool called on non-bool: %#v", v))
	}
	return v.val.(bool)
}

// Float64 returns the value as a float64, it panics if Kind() != KindFloat64
func (v *Value) Float64() float64 {
	if v.kind != KindFloat64 {
		panic(fmt.Errorf("automerge.Value#Float64 called on non-float64: %#v", v))
	}
	return v.val.(float64)
}

// Int64 returns the value as a int64, it panics if Kind() != KindInt64
func (v *Value) Int64() int64 {
	if v.kind != KindInt64 {
		panic(fmt.Errorf("automerge.Value#Int64 called on non-int64: %#v", v))
	}
	return v.val.(int64)
}

// Uint64 returns the value as a uint64, it panics if Kind() != KindUint64
func (v *Value) Uint64() uint64 {
	if v.kind != KindUint64 {
		panic(fmt.Errorf("automerge.Value#Uint64 called on non-uint64: %#v", v))
	}
	return v.val.(uint64)
}

// Time returns the value as a time.Time, it panics if Kind() != KindTime
func (v *Value) Time() time.Time {
	if v.kind != KindTime {
		panic(fmt.Errorf("automerge.Value#Time called on non-time: %#v", v))
	}
	return v.val.(time.Time)
}

// IsVoid returns true if the value did not exist in the document
func (v *Value) IsVoid() bool {
	return v.kind == KindVoid
}

// IsUnknown returns true if the type of the value was unknown
func (v *Value) IsUnknown() bool {
	return v.kind == KindUnknown
}

// IsNull returns true if the value is null
func (v *Value) IsNull() bool {
	return v.kind == KindNull
}

// GoString returns a representation suitable for debugging.
func (v *Value) GoString() string {
	if v.kind == KindVoid {
		return "&automerge.Value(<void>)"
	}
	return fmt.Sprintf("&automerge.Value(%#v)", v.val)
}

type initer interface {
	init(r *C.AMresult) error
}

func createValue(d *Doc, r *C.AMresult) (*Value, error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret := new(Value)
		err := ret.init(d, r)
		if err != nil {
			return nil, err
		}
		return ret, nil
	case C.AM_STATUS_ERROR:
		msg := fromByteSpanStr(C.AMerrorMessage(r))
		C.AMfree(r)
		return nil, fmt.Errorf(msg)
	case C.AM_STATUS_INVALID_RESULT:
		C.AMfree(r)
		return nil, fmt.Errorf("automerge: invalid result")
	default:
		C.AMfree(r)
		return nil, fmt.Errorf("automerge: invalid result status")
	}
}

func call[T interface {
	*X
	initer
}, X any](r *C.AMresult) (ret T, err error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret = T(new(X))
		err = ret.init(r)
	case C.AM_STATUS_ERROR:
		msg := fromByteSpanStr(C.AMerrorMessage(r))
		err = fmt.Errorf(msg)
	case C.AM_STATUS_INVALID_RESULT:
		err = fmt.Errorf("automerge: invalid result")
	default:
		err = fmt.Errorf("automerge: invalid result status")
	}

	if err != nil {
		C.AMfree(r)
		return nil, err
	}

	runtime.SetFinalizer(ret, func(ret T) { C.AMfree(r) })
	return ret, nil
}

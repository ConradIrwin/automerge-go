package automerge

//go:generate go run generate/gen.go

/*
#cgo LDFLAGS: -lautomerge
#cgo darwin,arm64 LDFLAGS: -L${SRCDIR}/deps/darwin_arm64
#cgo darwin,arm64 CFLAGS: -I${SRCDIR}/deps/darwin_arm64 -Wall

#include "automerge.h"
#include <stdlib.h>

// The below is generated by `go run ./generate/gen.go`
// unions are not directly supported by cgo, so there are accessors for
// the various flavors of AMvalue either passing the AMresult

AMvalueVariant AMresultValueTag(AMresult *r) { return AMresultValue(r).tag; }
const struct AMactorId *AMresultValueActorId(AMresult *r) { return AMresultValue(r).actor_id; }
bool AMresultValueBoolean(AMresult *r) { return AMresultValue(r).boolean; }
struct AMbyteSpan AMresultValueBytes(AMresult *r) { return AMresultValue(r).bytes; }
struct AMchangeHashes AMresultValueChangeHashes(AMresult *r) { return AMresultValue(r).change_hashes; }
struct AMchanges AMresultValueChanges(AMresult *r) { return AMresultValue(r).changes; }
int64_t AMresultValueCounter(AMresult *r) { return AMresultValue(r).counter; }
struct AMdoc *AMresultValueDoc(AMresult *r) { return AMresultValue(r).doc; }
double AMresultValueF64(AMresult *r) { return AMresultValue(r).f64; }
int64_t AMresultValueInt(AMresult *r) { return AMresultValue(r).int_; }
struct AMlistItems AMresultValueListItems(AMresult *r) { return AMresultValue(r).list_items; }
struct AMmapItems AMresultValueMapItems(AMresult *r) { return AMresultValue(r).map_items; }
const struct AMobjId *AMresultValueObjId(AMresult *r) { return AMresultValue(r).obj_id; }
struct AMobjItems AMresultValueObjItems(AMresult *r) { return AMresultValue(r).obj_items; }
const char *AMresultValueStr(AMresult *r) { return AMresultValue(r).str; }
struct AMstrs AMresultValueStrs(AMresult *r) { return AMresultValue(r).strs; }
const struct AMsyncMessage *AMresultValueSyncMessage(AMresult *r) { return AMresultValue(r).sync_message; }
struct AMsyncState *AMresultValueSyncState(AMresult *r) { return AMresultValue(r).sync_state; }
int64_t AMresultValueTimestamp(AMresult *r) { return AMresultValue(r).timestamp; }
uint64_t AMresultValueUint(AMresult *r) { return AMresultValue(r).uint; }
struct AMunknownValue AMresultValueUnknown(AMresult *r) { return AMresultValue(r).unknown; }
*/
import "C"
import (
	"fmt"
	"runtime"
	"time"
	"unsafe"

	"github.com/sasha-s/go-deadlock"
)

// Kind represents the underlying type of a Value
type Kind uint

var (
	// KindVoid indicates the value was not present
	KindVoid Kind = C.AM_VALUE_VOID
	// KindBool indicates a bool
	KindBool Kind = C.AM_VALUE_BOOLEAN
	// KindBytes indicates a []byte
	KindBytes Kind = C.AM_VALUE_BYTES
	// KindFloat64 indicates a float64
	KindFloat64 Kind = C.AM_VALUE_F64
	// KindInt indicates an int
	KindInt Kind = C.AM_VALUE_INT
	// KindUint indicates a uint
	KindUint Kind = C.AM_VALUE_UINT
	// KindNull indicates an explicit null was present
	KindNull Kind = C.AM_VALUE_NULL
	// KindStr indicates a string
	KindStr Kind = C.AM_VALUE_STR
	// KindTime indicates a time.Time
	KindTime Kind = C.AM_VALUE_TIMESTAMP

	// KindCounter indicates an *automerge.Counter
	KindCounter Kind = C.AM_VALUE_COUNTER
	// KindMap indicates an *automerge.Map
	KindMap Kind = C.AM_VALUE_MAP_ITEMS
	// KindList indicates an *automerge.List
	KindList Kind = C.AM_VALUE_LIST_ITEMS
	// KindText indicates an *automerge.Text
	KindText Kind = 1024
)

// ActorId represents an actor working on the document.
type ActorId struct {
	v *C.AMactorId
}

func (a *ActorId) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_ACTOR_ID {
		return fmt.Errorf("expected VALUE_ACTOR_ID, got %v", tag)
	}

	a.v = C.AMresultValueActorId(r)
	return nil
}

func (a *ActorId) forC(f func(v *C.AMactorId)) {
	defer runtime.KeepAlive(a)
	f(a.v)
}

// NewActorId creates a new random actor id
func NewActorId() (*ActorId, error) {
	return call[*ActorId](C.AMactorIdInit())
}

// ActorIdFromString creates an actor id from a string.
// The string must be an even number of hex characters.
func ActorIdFromString(id string) (*ActorId, error) {
	cstr := C.CString(id)
	defer C.free(unsafe.Pointer(cstr))
	return call[*ActorId](C.AMactorIdInitStr(cstr))
}

// ActorIdFromBytes creates an actor id from those bytes
func ActorIdFromBytes(id []byte) (*ActorId, error) {
	cbytes := C.CBytes(id)
	defer C.free(cbytes)
	return call[*ActorId](C.AMactorIdInitBytes((*C.uchar)(cbytes), C.ulong(len(id))))
}

// Bytes returns the underlying bytes of the actor id
func (a *ActorId) Bytes() []byte {
	defer runtime.KeepAlive(a)
	ret := C.AMactorIdBytes(a.v)
	return C.GoBytes(unsafe.Pointer(ret.src), C.int(ret.count))
}

// String returns the hex-encoded form of the actor id bytes
func (a *ActorId) String() string {
	defer runtime.KeepAlive(a)
	return C.GoString(C.AMactorIdStr(a.v))
}

// Cmp returns 0 if the two actor ids are identical,
// -1 if a < b and 1 if b > a
func (a *ActorId) Cmp(b *ActorId) int {
	defer runtime.KeepAlive(a)
	defer runtime.KeepAlive(b)
	return int(C.AMactorIdCmp(a.v, b.v))
}

// Doc represents an automerge document
type Doc struct {
	cDoc *C.AMdoc

	m deadlock.Mutex
}

func (d *Doc) lock() (*C.AMdoc, func()) {
	d.m.Lock()
	locked := true
	return d.cDoc, func() {
		if locked {
			locked = false
			d.m.Unlock()
		}
	}
}

func (d *Doc) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_DOC {
		return fmt.Errorf("expected VALUE_DOC, got %v", tag)
	}

	d.cDoc = C.AMresultValueDoc(r)
	return nil
}

// New creates a new document from actorId. If actorId == nil then
// a new random actor id will be created.
func New(actorId *ActorId) (*Doc, error) {
	var a *C.AMactorId
	if actorId != nil {
		defer runtime.KeepAlive(actorId)
		a = actorId.v
	}

	return call[*Doc](C.AMcreate(a))
}

// Load loads a document from its serialized form
func Load(b []byte) (*Doc, error) {
	cbytes := C.CBytes(b)
	defer C.free(unsafe.Pointer(cbytes))

	return call[*Doc](C.AMload((*C.uchar)(cbytes), C.ulong(len(b))))
}

// Save exports a document to its serialized form
func (d *Doc) Save() ([]byte, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	b, err := call[*byteSpan](C.AMsave(cDoc))
	if err != nil {
		return nil, err
	}
	return b.bytes(), nil
}

// Root returns the root of the document as a Map
// for modification (use .Get() to get the value for reading)
func (d *Doc) Root() *Map {
	return &Map{doc: d, objId: &objId{v: (*C.AMobjId)(C.AM_ROOT)}}
}

// Get returns the root of the document, it is always
// a Value with Kind() == KindMap
func (d *Doc) Get() *Value {
	return &Value{kind: KindMap, val: d.Root()}
}

// Path returns a path that points to a position in the doc.
// Each path component must be of type string or int.
// Creating a path will always succeed, and any errors caused
// by trying to traverse the path will be reported when it is
// actually used.
func (d *Doc) Path(path ...any) *Path {
	return (&Path{d: d}).Path(path...)
}

// Commit adds a new version to the document with all
// local changes so far.
func (d *Doc) Commit(msg string) (*ChangeHashes, error) {
	cstr := C.CString(msg)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMcommit(cDoc, cstr, nil))
}

// Heads returns the current heads for the document
func (d *Doc) Heads() (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ChangeHashes](C.AMgetHeads(cDoc))
}

// Fork returns a new, independent, copy of the document
// if asOf == nil then it is forked in its current state.
// otherwise it returns a version as of the given Change Hashes.
func (d *Doc) Fork(asOf *ChangeHashes) (*Doc, error) {
	cDoc, unlock := d.lock()
	defer unlock()
	defer runtime.KeepAlive(asOf)

	if asOf == nil {
		return call[*Doc](C.AMfork(cDoc, nil))
	}

	return call[*Doc](C.AMfork(cDoc, &asOf.v))
}

// Merge extracts all changes from d2 that are not in d
// and then applies them to d.
func (d *Doc) Merge(d2 *Doc) (*ChangeHashes, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	cDoc2, unlock2 := d2.lock()
	defer unlock2()

	return call[*ChangeHashes](C.AMmerge(cDoc, cDoc2))
}

// ActorId returns the current actorId of the doc.
func (d *Doc) ActorId() (*ActorId, error) {
	cDoc, unlock := d.lock()
	defer unlock()

	return call[*ActorId](C.AMgetActorId(cDoc))
}

type byteSpan struct {
	v C.AMbyteSpan
}

func (bs *byteSpan) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_BYTES {
		return fmt.Errorf("expected VALUE_BYTES, got %v", tag)
	}

	bs.v = C.AMresultValueBytes(r)
	return nil
}

func (bs *byteSpan) bytes() []byte {
	return C.GoBytes(unsafe.Pointer(bs.v.src), C.int(bs.v.count))
}

type objId struct {
	r *C.AMresult
	v *C.AMobjId
}

func (o *objId) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_OBJ_ID {
		return fmt.Errorf("expected VALUE_OBJ_ID, got %v", tag)
	}

	o.r = r
	o.v = C.AMresultValueObjId(r)
	return nil
}

type void struct{}

func (*void) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_VOID {
		return fmt.Errorf("expected VALUE_VOID, got %v", tag)
	}

	return nil
}

// ChangeHashes are used to represent a version of the document
// This is done by returning a list of changeHashes because there is no
// fixed global ordering.
type ChangeHashes struct {
	v C.AMchangeHashes
}

func (ch *ChangeHashes) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_CHANGE_HASHES {
		return fmt.Errorf("expected VALUE_CHANGE_HASHES, got %v", tag)
	}
	ch.v = C.AMresultValueChangeHashes(r)
	return nil
}

// Map is an automerge type that stores a map of strings to values
type Map struct {
	doc   *Doc
	objId *objId
	path  *Path
}

func (m *Map) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := m.doc.lock()
	return cDoc, m.objId.v, unlock
}

func NewMap() *Map {
	return &Map{}
}

func NewList() *List {
	return &List{}
}

// Set sets a key in the map to a given value.
// This method may error if the underlying operation errors,
// the type you provide cannot be converted to an automerge type,
// or if this is the first write to a Path.Map() and the path is not traverseable.
func (m *Map) Set(key string, value any) error {
	if m.objId == nil {
		if m.path == nil {
			return fmt.Errorf("automerge.Map#Set called on detached Map")
		}
		m2, err := m.path.ensureMap(key)
		if err != nil {
			return err
		}
		m.objId = m2.objId
	}

	cstr := C.CString(key)
	defer C.free(unsafe.Pointer(cstr))

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	value, err := normalize(value)
	if err != nil {
		return err
	}

	if value == nil {
		_, err := call[*void](C.AMmapPutNull(cDoc, cObj, cstr))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMmapPutBool(cDoc, cObj, cstr, C.bool(v)))
	case string:
		vstr := C.CString(v)
		defer C.free(unsafe.Pointer(vstr))
		_, err = call[*void](C.AMmapPutStr(cDoc, cObj, cstr, vstr))

	case []byte:
		vbytes := C.CBytes(v)
		defer C.free(vbytes)
		_, err = call[*void](C.AMmapPutBytes(cDoc, cObj, cstr, (*C.uchar)(vbytes), C.ulong(len(v))))

	case int64:
		_, err = call[*void](C.AMmapPutInt(cDoc, cObj, cstr, C.longlong(v)))

	case uint64:
		_, err = call[*void](C.AMmapPutUint(cDoc, cObj, cstr, C.ulonglong(v)))

	case float64:
		_, err = call[*void](C.AMmapPutF64(cDoc, cObj, cstr, C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMmapPutTimestamp(cDoc, cObj, cstr, C.longlong(v.UnixMilli())))

	case []any:
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		list := &List{doc: m.doc, objId: objId}
		unlock()
		for _, item := range v {
			if err := list.Append(item); err != nil {
				return err
			}
		}

	case map[string]any:
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		m := &Map{doc: m.doc, objId: objId}
		unlock()
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Map:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map#Set: cannot move an existing *automerge.Map")
		}

		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		v.doc = m.doc
		v.objId = objId

	case *List:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map#Set: cannot move an existing *automerge.List")
		}

		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objId = objId

	case *Counter:
		if v.m != nil || v.l != nil {
			return fmt.Errorf("automerge.Map#Set: cannot move an existing *automerge.Counter")
		}

		_, err = call[*void](C.AMmapPutCounter(cDoc, cObj, cstr, C.longlong(v.val)))
		if err == nil {
			v.m = m
			v.key = key
		}

	case *Text:
		if v.objId != nil {
			return fmt.Errorf("automerge.Map#Set: cannot move an existing *automerge.Text")
		}
		objId, err := call[*objId](C.AMmapPutObject(cDoc, cObj, cstr, C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = m.doc
		v.objId = objId
		unlock()
		err = v.Reset(v.val)

	case *void:
		_, err = call[*void](C.AMmapDelete(cDoc, cObj, cstr))

	default:
		err = fmt.Errorf("automerge.Map#Set: unsupported value %#v of type %#T", value, value)
	}

	return err
}

// Del deletes a key and its corresponding value from the map
func (m *Map) Del(key string) error {
	return m.Set(key, &void{})
}

// Get retrieves the value from the map.
// This method will return an error if the underlying Get
// operation fails, or if this is the first attempt to access
// a Path.Map() and the path is not traverseable
func (m *Map) Get(key string) (*Value, error) {
	if m.objId == nil {
		if m.path == nil {
			return nil, fmt.Errorf("automerge.Map#Get called on detached Map")
		}
		return m.path.Path(key).Get()
	}

	cstr := C.CString(key)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := m.lock()
	defer unlock()

	r := C.AMmapGet(cDoc, cObj, cstr, nil)
	unlock()
	v, err := callValue(m.doc, r)
	if err == nil && v.Kind() == KindCounter {
		c := v.Counter()
		c.m = m
		c.key = key
	}
	return v, err
}

// load loads the map into go values (recrusively)
func (m *Map) load() (map[string]any, error) {
	iter := m.Iter()

	ret := map[string]any{}

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

func (m *Map) Iter() *MapItems {
	if m.objId == nil {
		if m.path == nil {
			return &MapItems{err: fmt.Errorf("automerge.Map#Iter called on detached Map")}
		}
		v, err := m.path.Get()
		if err != nil {
			return &MapItems{err: err}
		}
		if v.Kind() == KindMap {
			return v.Map().Iter()
		} else if v.Kind() == KindVoid {
			return &MapItems{}
		}
		return &MapItems{err: fmt.Errorf("%#p: cannot interate over non-map %v", m.path, v)}
	}

	cDoc, cObj, unlock := m.lock()
	defer unlock()

	iter, err := call[*MapItems](C.AMmapRange(cDoc, cObj, nil, nil, nil))
	if err != nil {
		return &MapItems{err: err}
	}
	iter.m = m
	return iter
}

// MapItems iterates over the values in a Map
type MapItems struct {
	r *C.AMresult
	v C.AMmapItems
	m *Map

	err error
}

func (mi *MapItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_MAP_ITEMS {
		return fmt.Errorf("expected VALUE_MAP_ITEMS, got %v", tag)
	}

	mi.r = r
	mi.v = C.AMresultValueMapItems(r)
	return nil
}

// Next returns either the next key and value and true
// or "", nil, false to indicate that there are no more items
func (mi *MapItems) Next() (string, *Value, bool) {
	if mi.err != nil || mi.r == nil {
		return "", nil, false
	}
	defer runtime.KeepAlive(mi)

	item := C.AMmapItemsNext(&mi.v, 1)
	if item == nil {
		return "", nil, false
	}

	cKey := C.AMmapItemKey(item)
	key := C.GoString(cKey)

	// TODO: we should get the value from the mapItems instead to be concurrency safe.
	value, err := mi.m.Get(key)
	if err != nil {
		mi.err = err
		return "", nil, false
	}

	return key, value, true
}

// Error returns any error that happened when creating
// or iterating over the map.
func (mi *MapItems) Error() error {
	return mi.err
}

type List struct {
	doc   *Doc
	objId *objId
	path  *Path
}

func (l *List) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := l.doc.lock()
	return cDoc, l.objId.v, unlock
}

func (l *List) load() ([]any, error) {
	iter := l.Iter()

	ret := make([]any, l.Len())

	for {
		k, v, valid := iter.Next()
		if !valid {
			break
		}
		v2, err := v.goValue()
		if err != nil {
			return nil, err
		}
		ret[k] = v2
	}

	if err := iter.Error(); err != nil {
		return nil, err
	}

	return ret, nil
}

func (l *List) Len() int {
	if l.objId == nil {
		l, err := As[*List](l.path.Get())
		if err != nil {
			return 0
		}
		return l.Len()
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()
	return int(C.AMobjSize(cDoc, cObj, nil))
}

func (l *List) Iter() *ListItems {
	if l.objId == nil {
		v, err := l.path.Get()
		if err != nil {
			return &ListItems{err: err}
		}
		if v.Kind() == KindList {
			return v.List().Iter()
		} else if v.Kind() == KindVoid {
			return &ListItems{}
		}
		return &ListItems{err: fmt.Errorf("%#p: cannot interate over non-list %v", l.path, v)}
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	iter, err := call[*ListItems](C.AMlistRange(cDoc, cObj, 0, C.SIZE_MAX, nil))
	if err != nil {
		return &ListItems{err: err}
	}
	iter.l = l
	return iter
}

func (l *List) Get(i int) (*Value, error) {
	if l.objId == nil {
		return l.path.Path(i).Get()
	}
	defer runtime.KeepAlive(l)

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	r := C.AMlistGet(cDoc, cObj, C.ulong(i), nil)
	unlock()
	v, err := callValue(l.doc, r)
	if err != nil {
		return nil, err
	}
	if v.Kind() == KindCounter {
		c := v.Counter()
		c.l = l
		c.idx = i
	}
	return v, nil
}

func (l *List) Append(value ...any) error {
	for _, v := range value {
		if err := l.put(C.SIZE_MAX, true, v); err != nil {
			return err
		}
	}
	return nil
}

func (l *List) Set(idx int, value any) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge: List.Set index %v out of bounds (list.Len() == %v", idx, l.Len())
		panic("list index must be > 0")
	}
	return l.put(C.ulong(idx), false, value)
}

func (l *List) Insert(idx int, value ...any) error {
	if idx < 0 || idx >= l.Len() {
		return fmt.Errorf("automerge: List.Insert index %v out of bounds (list.Len() == %v", idx, l.Len())
	}
	for i, v := range value {
		if err := l.put(C.ulong(idx+i), true, v); err != nil {
			return err
		}
	}
	return nil
}

func (l *List) put(i C.ulong, before bool, value any) error {
	if l.objId == nil {
		l2, err := l.path.ensureList(int(i))
		if err != nil {
			return err
		}
		l.objId = l2.objId
	}

	value, err := normalize(value)
	if err != nil {
		return err
	}

	cDoc, cObj, unlock := l.lock()
	defer unlock()

	if value == nil {
		_, err := call[*void](C.AMlistPutNull(cDoc, cObj, i, C.bool(before)))
		return err
	}

	switch v := value.(type) {
	case bool:
		_, err = call[*void](C.AMlistPutBool(cDoc, cObj, i, C.bool(before), C.bool(v)))
	case string:
		vstr := C.CString(v)
		defer C.free(unsafe.Pointer(vstr))
		_, err = call[*void](C.AMlistPutStr(cDoc, cObj, i, C.bool(before), vstr))

	case []byte:
		vbytes := C.CBytes(v)
		defer C.free(vbytes)
		_, err = call[*void](C.AMlistPutBytes(cDoc, cObj, i, C.bool(before), (*C.uchar)(vbytes), C.ulong(len(v))))

	case int64:
		_, err = call[*void](C.AMlistPutInt(cDoc, cObj, i, C.bool(before), C.longlong(v)))

	case uint64:
		_, err = call[*void](C.AMlistPutUint(cDoc, cObj, i, C.bool(before), C.ulonglong(v)))

	case float64:
		_, err = call[*void](C.AMlistPutF64(cDoc, cObj, i, C.bool(before), C.double(v)))

	case time.Time:
		_, err = call[*void](C.AMlistPutTimestamp(cDoc, cObj, i, C.bool(before), C.longlong(v.UnixMilli())))

	case []any:
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		unlock()
		list := &List{doc: l.doc, objId: objId}
		for idx, item := range v {
			if err := list.Set(idx, item); err != nil {
				return err
			}
		}

	case map[string]any:
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}

		unlock()
		m := &Map{doc: l.doc, objId: objId}
		for key, val := range v {
			if err := m.Set(key, val); err != nil {
				return err
			}
		}

	case *Counter:
		_, err = call[*void](C.AMlistPutCounter(cDoc, cObj, i, C.bool(before), C.longlong(v.val)))
		if err == nil {
			v.l = l
			v.idx = int(i)
		}

	case *Text:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: cannot move an attached *automerge.Text")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_TEXT))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId
		err = v.Reset(v.val)

	case *Map:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: cannot move an attached *automerge.Map")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_MAP))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId

	case *List:
		if v.objId != nil {
			return fmt.Errorf("automerge.List: cannot move an attached *automerge.List")
		}
		objId, err := call[*objId](C.AMlistPutObject(cDoc, cObj, i, C.bool(before), C.AM_OBJ_TYPE_LIST))
		if err != nil {
			return err
		}
		v.doc = l.doc
		v.objId = objId

	default:
		err = fmt.Errorf("automerge: unsupported %#v of type %T", value, value)
	}

	return err
}

type ListItems struct {
	r *C.AMresult
	v C.AMlistItems
	l *List

	err error
}

func (li *ListItems) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_LIST_ITEMS {
		return fmt.Errorf("expected VALUE_LIST_ITEMS, got %v", tag)
	}

	li.r = r
	li.v = C.AMresultValueListItems(r)
	return nil
}

func (li *ListItems) Next() (int, *Value, bool) {
	if li.err != nil {
		return 0, nil, false
	}
	defer runtime.KeepAlive(li)

	item := C.AMlistItemsNext(&li.v, 1)
	if item == nil {
		return 0, nil, false
	}

	idx := C.AMlistItemIndex(item)

	value, err := li.l.Get(int(idx))
	if err != nil {
		li.err = err
		return 0, nil, false
	}

	return int(idx), value, true
}

func (li *ListItems) Error() error {
	return li.err
}

type Counter struct {
	val int64

	path *Path

	m   *Map
	key string
	l   *List
	idx int
}

func NewCounter(v int64) *Counter {
	return &Counter{val: v}
}

func (c *Counter) Get() (int64, error) {
	var v *Value
	var err error
	if c.m != nil {
		v, err = c.m.Get(c.key)
	} else if c.l != nil {
		v, err = c.l.Get(c.idx)
	} else if c.path != nil {
		v, err = c.path.Get()
	} else {
		return 0, fmt.Errorf("automerge.Counter#Get called on detached counter")
	}
	if err != nil {
		return 0, err
	}

	if v.Kind() != KindCounter {
		return 0, fmt.Errorf("automerge.Counter#Get called on non-counter %#v of type %T", v.val, v.val)
	}
	return v.Counter().val, nil
}

func (c *Counter) Inc(delta int) error {
	if c.m == nil && c.l == nil {
		if c.path == nil {
			return fmt.Errorf("automerge.Counter#Inc called on detached counter")
		}

		c2, err := c.path.ensureCounter()
		if err != nil {
			return err
		}
		c.l = c2.l
		c.idx = c2.idx
		c.m = c2.m
		c.key = c2.key
	}

	if c.l != nil {
		cDoc, cObj, unlock := c.l.lock()
		defer unlock()
		_, err := call[*void](C.AMlistIncrement(cDoc, cObj, C.ulong(c.idx), C.longlong(delta)))
		return err
	}

	cstr := C.CString(c.key)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := c.m.lock()
	defer unlock()
	_, err := call[*void](C.AMmapIncrement(cDoc, cObj, cstr, C.longlong(delta)))
	return err
}

func (c *Counter) String() string {
	return c.GoString()
}

func (c *Counter) GoString() string {
	v, err := c.Get()
	if err != nil {
		return fmt.Sprintf("&automerge.Counter(<error>)")
	}
	return fmt.Sprintf("&automerge.Counter(%v)", v)
}

type Text struct {
	doc   *Doc
	objId *objId
	path  *Path

	val string
}

func (t *Text) lock() (*C.AMdoc, *C.AMobjId, func()) {
	cDoc, unlock := t.doc.lock()
	return cDoc, t.objId.v, unlock
}

func NewText(s string) *Text {
	return &Text{val: s}
}

func (t *Text) Get() (string, error) {
	if t.objId == nil {
		if t.path == nil {
			return "", fmt.Errorf("automerge.Text: cannot Get detached text")
		}
		t, err := As[*Text](t.path.Get())
		if err != nil {
			return "", err
		}
		return t.Get()
	}

	cDoc, cObj, unlock := t.lock()
	defer unlock()

	us, err := call[*utf8String](C.AMtext(cDoc, cObj, nil))
	if err != nil {
		return "", err
	}
	return us.val, nil
}

func (t *Text) Reset(s string) error {
	return t.splice(0, C.SIZE_MAX, s)
}

func (t *Text) Insert(pos int, s string) error {
	return t.splice(C.ulong(pos), 0, s)
}

func (t *Text) Del(pos int, del int) error {
	return t.splice(C.ulong(pos), C.ulong(del), "")
}

func (t *Text) Append(s string) error {
	return t.splice(C.SIZE_MAX, 0, s)
}

func (t *Text) Splice(pos int, del int, s string) error {
	return t.splice(C.ulong(pos), C.ulong(del), s)
}

func (t *Text) splice(pos, del C.ulong, s string) error {
	if t.objId == nil {
		if t.path == nil {
			return fmt.Errorf("automerge.Text edited while detached")
		}
		t2, err := t.path.ensureText()
		if err != nil {
			return err
		}
		t.doc = t2.doc
		t.objId = t2.objId
	}

	cstr := C.CString(s)
	defer C.free(unsafe.Pointer(cstr))
	cDoc, cObj, unlock := t.lock()
	defer unlock()

	_, err := call[*void](C.AMspliceText(cDoc, cObj, pos, del, cstr))
	if err != nil {
		return err
	}
	return nil
}

func (t *Text) String() string {
	return t.GoString()
}

func (t *Text) GoString() string {
	v, err := t.Get()
	if err != nil {
		return fmt.Sprintf("&automerge.Text(<error>)")
	}
	return fmt.Sprintf("&automerge.Text(%#v)", v)
}

type utf8String struct {
	val string
}

func (us *utf8String) init(r *C.AMresult) error {
	if tag := C.AMresultValueTag(r); tag != C.AM_VALUE_STR {
		return fmt.Errorf("expected VALUE_STR, got %v", tag)
	}

	us.val = C.GoString(C.AMresultValueStr(r))
	return nil
}

type Value struct {
	kind Kind
	val  any
}

func (v *Value) init(d *Doc, r *C.AMresult) error {
	tag := C.AMresultValueTag(r)

	if tag == C.AM_VALUE_OBJ_ID {
		return v.initObjId(d, r)
	}

	v.kind = Kind(tag)
	switch v.kind {
	case KindBool:
		v.val = bool(C.AMresultValueBoolean(r))

	case KindNull, KindVoid:
		v.val = nil

	case KindStr:
		v.val = C.GoString(C.AMresultValueStr(r))

	case KindBytes:
		span := C.AMresultValueBytes(r)
		v.val = C.GoBytes(unsafe.Pointer(span.src), C.int(span.count))

	case KindFloat64:
		v.val = float64(C.AMresultValueF64(r))

	case KindInt:
		v.val = int64(C.AMresultValueInt(r))

	case KindUint:
		v.val = uint64(C.AMresultValueInt(r))

	case KindCounter:
		v.val = &Counter{val: int64(C.AMresultValueCounter(r))}

	case KindTime:
		v.val = time.UnixMilli(int64(C.AMresultValueTimestamp(r)))

	default:
		return fmt.Errorf("expected a bool/null/string/bytes/float/int/uint value, got %#v", v.kind)
	}

	C.AMfree(r)
	return nil
}

func (v *Value) initObjId(d *Doc, r *C.AMresult) error {
	o := &objId{r: r, v: C.AMresultValueObjId(r)}
	runtime.SetFinalizer(o, func(*objId) { C.AMfree(r) })

	cDoc, unlock := d.lock()
	defer unlock()

	switch C.AMobjObjType(cDoc, o.v) {
	case C.AM_OBJ_TYPE_LIST:
		v.kind = KindList
		v.val = &List{doc: d, objId: o}
	case C.AM_OBJ_TYPE_MAP:
		v.kind = KindMap
		v.val = &Map{doc: d, objId: o}
	case C.AM_OBJ_TYPE_TEXT:
		v.kind = KindText
		v.val = &Text{doc: d, objId: o}

	default:
		return fmt.Errorf("expected a list/map, got %#v", C.AMobjObjType(d.cDoc, o.v))
	}

	return nil
}

func (v *Value) goValue() (any, error) {
	if v.kind == KindCounter {
		return v.Counter().Get()
	}
	if v.kind == KindText {
		return v.Text().Get()
	}
	if v.kind == KindList {
		return v.List().load()
	}
	if v.kind == KindMap {
		return v.Map().load()
	}
	return v.val, nil
}

func (v *Value) Kind() Kind {
	return v.kind
}

func (v *Value) List() *List {
	if v.kind != KindList {
		panic("automerge.Value#List called on non-list")
	}
	return v.val.(*List)
}

func (v *Value) Map() *Map {
	if v.kind != KindMap {
		panic(fmt.Errorf("automerge.Value#Map called on non-map: %#v", v))
	}
	return v.val.(*Map)
}

func (v *Value) Counter() *Counter {
	if v.kind != KindCounter {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Counter)
}

func (v *Value) Text() *Text {
	if v.kind != KindText {
		panic(fmt.Errorf("automerge.Value#Counter called on non-counter: %#v", v))
	}

	return v.val.(*Text)
}

func (v *Value) Str() string {
	if v.kind != KindStr {
		panic(fmt.Errorf("automerge.Value#Str called on non-string: %#v", v))
	}
	return v.val.(string)
}

func (v *Value) String() string {
	return v.GoString()
}

func (v *Value) IsVoid() bool {
	return v.kind == KindVoid
}

func (v *Value) IsNull() bool {
	return v.kind == KindNull
}

func (v *Value) GoString() string {
	if v.kind == KindVoid {
		return "&automerge.Value(<void>)"
	}
	return fmt.Sprintf("&automerge.Value(%#v)", v.val)
}

type initer interface {
	init(r *C.AMresult) error
}

func callValue(d *Doc, r *C.AMresult) (ret *Value, err error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret = new(Value)
		err = ret.init(d, r)
	case C.AM_STATUS_ERROR:
		err = fmt.Errorf(C.GoString(C.AMerrorMessage(r)))
	case C.AM_STATUS_INVALID_RESULT:
		err = fmt.Errorf("automerge: invalid result")
	default:
		err = fmt.Errorf("automerge: invalid result status")
	}

	if err != nil {
		C.AMfree(r)
		return nil, err
	}
	return ret, nil
}

func call[T interface {
	*X
	initer
}, X any](r *C.AMresult) (ret T, err error) {
	switch C.AMresultStatus(r) {
	case C.AM_STATUS_OK:
		ret = T(new(X))
		err = ret.init(r)
	case C.AM_STATUS_ERROR:
		err = fmt.Errorf(C.GoString(C.AMerrorMessage(r)))
	case C.AM_STATUS_INVALID_RESULT:
		err = fmt.Errorf("automerge: invalid result")
	default:
		err = fmt.Errorf("automerge: invalid result status")
	}

	if err != nil {
		C.AMfree(r)
		return nil, err
	}

	runtime.SetFinalizer(ret, func(ret T) { C.AMfree(r) })
	return ret, nil
}

func TestNullByte(b []byte) {
	result := C.AMload((*C.uchar)(unsafe.Pointer(&b[0])), (C.ulong)(len(b)))

	if s := C.AMresultStatus(result); s != C.AM_STATUS_OK {
		fmt.Println("got incorrect status: ", s)
		return
	}

	doc := C.AMresultValueDoc(result)

	cstr := C.CString("oops")

	result = C.AMmapGet(doc, (*C.AMobjId)(C.AM_ROOT), cstr, nil)

	if s := C.AMresultStatus(result); s != C.AM_STATUS_OK {
		fmt.Println("got incorrect status 2: ", s)
		return
	}

	err := C.GoString(C.AMerrorMessage(result))
	fmt.Println("GOT ERR", err)

	return

	tag := C.AMresultValueTag(result)
	fmt.Println(tag)

	fmt.Println("SUCCESS")

}
